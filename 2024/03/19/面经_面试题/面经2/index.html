<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="referrer" content="no-referrer">

    <meta name="author" content="Zachary Block">





<title>面经2 | Zachary Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Zachary Blog" type="application/atom+xml">
</head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Zachary&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">归档</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Zachary&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">归档</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">面经2</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Zachary Block</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">3 月 19 日&nbsp;&nbsp;0:10:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Python-%E9%9D%A2%E7%BB%8F/">Python 面经</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="面经-2"><a href="#面经-2" class="headerlink" title="面经 2"></a>面经 2</h1><h5 id="题目-001-在-Python-中如何实现单例模式。"><a href="#题目-001-在-Python-中如何实现单例模式。" class="headerlink" title="题目 001: 在 Python 中如何实现单例模式。"></a><font style="color:rgb(85, 87, 112);">题目 001: 在 Python 中如何实现单例模式。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：单例模式是指让一个类只能创建出唯一的实例，这个题目在面试中出现的频率极高，因为它考察的不仅仅是单例模式，更是对 Python 语言到底掌握到何种程度，建议大家用装饰器和元类这两种方式来实现单例模式，因为这两种方式的通用性最强，而且也可以顺便展示自己对装饰器和元类中两个关键知识点的理解。</font></p>
<p>方法一：使用装饰器实现单例模式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">singleton</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单例类装饰器&quot;&quot;&quot;</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(<span class="params">cls</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">President</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">扩展</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：装饰器是 Python 中非常有特色的语法，用一个函数去装饰另一个函数或类，为其添加额外的能力。通常通过装饰来实现的功能都属横切关注功能，也就是跟正常的业务逻辑没有必然联系，可以动态添加或移除的功能。装饰器可以为代码提供缓存、代理、上下文环境等服务，它是对设计模式中代理模式的践行。在写装饰器的时候，带装饰功能的函数（上面代码中的</font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">wrapper</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">函数）通常都会用</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">functools</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">模块中的</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">wraps</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">再加以装饰，这个装饰器最重要的作用是给被装饰的类或函数动态添加一个</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>wrapped</strong></font></em><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">属性，这个属性会将被装饰之前的类或函数保留下来，这样在我们不需要装饰功能的时候，可以通过它来取消装饰器，例如可以使用</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">President</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">&#x3D;</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">President.<strong>wrapped</strong></font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">来取消对</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">President</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">类做的单例处理。需要提醒大家的是：上面的单例并不是线程安全的，如果要做到线程安全，需要对创建对象的代码进行加锁的处理。在 Python 中可以使用</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">threading</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">模块的</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">RLock</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">对象来提供锁，可以使用锁对象的</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">acquire</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">和</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">release</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">方法来实现加锁和解锁的操作。当然，更为简便的做法是使用锁对象的</font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">with</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">上下文语法来进行隐式的加锁和解锁操作。</font></p>
<p>方法二：使用元类实现单例模式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义单例元类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        cls.__instance = <span class="literal">None</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls.__instance = <span class="built_in">super</span>().__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">President</span>(metaclass=SingletonMeta):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">扩展</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：Python 是面向对象的编程语言，在面向对象的世界中，一切皆为对象。对象是通过类来创建的，而类本身也是对象，类这样的对象是通过元类来创建的。我们在定义类时，如果没有给一个类指定父类，那么默认的父类是</font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">object</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，如果没有给一个类指定元类，那么默认的元类是</font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">type</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">。通过自定义的元类，我们可以改变一个类默认的行为，就如同上面的代码中，我们通过元类的</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>call</strong></font></em><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">魔术方法，改变了</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">President</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">类的构造器那样。</font></p>
<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">补充</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：关于单例模式，在面试中还有可能被问到它的应用场景。通常一个对象的状态是被其他对象共享的，就可以将其设计为单例，例如项目中使用的数据库连接池对象和配置对象通常都是单例，这样才能保证所有地方获取到的</font><a href="https://link.csdn.net/?target=https://gitcode.com/SequoiaDB/SequoiaDB/overview">数据库</a><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">连接和配置信息是完全一致的；而且由于对象只有唯一的实例，因此从根本上避免了重复创建对象造成的时间和空间上的开销，也避免了对资源的多重占用。再举个例子，项目中的日志操作通常也会使用单例模式，这是因为共享的日志文件一直处于打开状态，只能有一个实例去操作它，否则在写入日志的时候会产生混乱。</font></p>
<h5 id="题目-002：不使用中间变量，交换两个变量a和b的值。"><a href="#题目-002：不使用中间变量，交换两个变量a和b的值。" class="headerlink" title="题目 002：不使用中间变量，交换两个变量a和b的值。"></a><font style="color:rgb(85, 87, 112);">题目 002：不使用中间变量，交换两个变量<code>a</code>和<code>b</code>的值。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：典型的送人头的题目，通常交换两个变量需要借助一个中间变量，如果不允许使用中间变量，在其他编程语言中可以使用异或运算的方式来实现交换两个变量的值，但是 Python 中有更为简单明了的做法。</font></p>
<p>方法一：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b</span><br><span class="line">b = a ^ b</span><br><span class="line">a = a ^ b</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">扩展</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：需要注意，</font><font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">a</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">,</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">b</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">&#x3D;</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">b</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">, a</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">这种做法其实并不是元组解包，虽然很多人都这样认为。Python 字节码指令中有</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">ROT_TWO</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">指令来支持这个操作，类似的还有</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">ROT_THREE</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，对于 3 个以上的元素，如</font><font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">a</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">,</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">b</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">, c, d &#x3D;</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">b</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">, c, d, a</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，才会用到创建元组和元组解包。想知道你的代码对应的字节码指令，可以使用 Python 标准库中</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">dis</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">模块的</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">dis</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">函数来反汇编你的 Python 代码。</font></p>
<h5 id="题目-003：写一个删除列表中重复元素的函数，要求去重后元素相对位置保持不变。"><a href="#题目-003：写一个删除列表中重复元素的函数，要求去重后元素相对位置保持不变。" class="headerlink" title="题目 003：写一个删除列表中重复元素的函数，要求去重后元素相对位置保持不变。"></a><font style="color:rgb(85, 87, 112);">题目 003：写一个删除列表中重复元素的函数，要求去重后元素相对位置保持不变。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：这个题目在初中级 Python 岗位面试的时候经常出现，题目源于《Python Cookbook》这本书第一章的第 10 个问题，有很多面试题其实都是这本书上的原题，所以建议大家有时间好好研读一下这本书。</font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dedup</span>(<span class="params">items</span>):</span><br><span class="line">    no_dup_items = []</span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            no_dup_items.append(item)</span><br><span class="line">            seen.add(item)</span><br><span class="line">    <span class="keyword">return</span> no_dup_items</span><br></pre></td></tr></table></figure>

<p>如果愿意也可以把上面的函数改造成一个生成器，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dedup</span>(<span class="params">items</span>):</span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">            seen.add(item)</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">扩展</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：由于 Python 中的集合底层使用哈希存储，所以集合的</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">in</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">和</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">not in</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">成员运算在性能上远远优于列表，所以上面的代码我们使用了集合来保存已经出现过的元素。集合中的元素必须是</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">hashable</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">对象，因此上面的代码在列表元素不是</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">hashable</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">对象时会失效，要解决这个问题可以给函数增加一个参数，该参数可以设计为返回哈希码或</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">hashable</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">对象的函数。</font></p>
<h5 id="题目-004：假设你使用的是官方的-CPython，说出下面代码的运行结果。"><a href="#题目-004：假设你使用的是官方的-CPython，说出下面代码的运行结果。" class="headerlink" title="题目 004：假设你使用的是官方的 CPython，说出下面代码的运行结果。"></a><font style="color:rgb(85, 87, 112);">题目 004：假设你使用的是官方的 CPython，说出下面代码的运行结果。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：下面的程序对实际开发并没有什么意义，但却是 CPython 中的一个大坑，这道题旨在考察面试者对官方的 Python 解释器到底了解到什么程度。</font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a, b, c, d = <span class="number">1</span>, <span class="number">1</span>, <span class="number">1000</span>, <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b, c <span class="keyword">is</span> d)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    e = <span class="number">1000</span></span><br><span class="line">    f = <span class="number">1000</span></span><br><span class="line">    <span class="built_in">print</span>(e <span class="keyword">is</span> f, e <span class="keyword">is</span> d)</span><br><span class="line">    g = <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(g <span class="keyword">is</span> a)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">True False</span><br><span class="line">True False</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>上面代码中<font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">a</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">is</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">b</font>的结果是<font style="color:rgb(86, 182, 194);background-color:rgb(40, 44, 52);">True</font>但<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">c</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">is</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">d</font>的结果是<font style="color:rgb(86, 182, 194);background-color:rgb(40, 44, 52);">False</font>，这一点的确让人费解。CPython 解释器出于性能优化的考虑，把频繁使用的整数对象用一个叫<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">small</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);"><em></font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">ints</font>的对象池缓存起来造成的。<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">small</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);"></em></font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">ints</font>缓存的整数值被设定为<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">[-5, 256]</font>这个区间，也就是说，在任何引用这些整数的地方，都不需要重新创建<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">int</font>对象，而是直接引用缓存池中的对象。如果整数不在该范围内，那么即便两个整数的值相同，它们也是不同的对象。</p>
<p>CPython 底层为了进一步提升性能还做了另一个设定，对于同一个代码块中值不在<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">small</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">_</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">ints</font>缓存范围内的整数，如果同一个代码块中已经存在一个值与其相同的整数对象，那么就直接引用该对象，否则创建新的<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">int</font>对象。需要大家注意的是，这条规则对数值型适用，但对字符串则需要考虑字符串的长度，这一点大家可以自行证明。</p>
<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">扩展</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：如果你用 PyPy（另一种 Python 解释器实现，支持 JIT，对 CPython 的缺点进行了改良，在性能上优于 CPython，但对三方库的支持略差）来运行上面的代码，你会发现所有的输出都是 True。</font></p>
<h5 id="题目-005：Lambda-函数是什么，举例说明的它的应用场景。"><a href="#题目-005：Lambda-函数是什么，举例说明的它的应用场景。" class="headerlink" title="题目 005：Lambda 函数是什么，举例说明的它的应用场景。"></a><font style="color:rgb(85, 87, 112);">题目 005：Lambda 函数是什么，举例说明的它的应用场景。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：这个题目主要想考察的是 Lambda 函数的应用场景，潜台词是问你在项目中有没有使用过 Lambda 函数，具体在什么场景下会用到 Lambda 函数，借此来判断你写代码的能力。因为 Lambda 函数通常用在高阶函数中，主要的作用是通过向函数传入函数或让函数返回函数最终实现代码的解耦合。</font></p>
<p>Lambda 函数也叫匿名函数，它是功能简单用一行代码就能实现的小型函数。Python 中的 Lambda 函数只能写一个表达式，这个表达式的执行结果就是函数的返回值，不用写<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">return</font>关键字。Lambda 函数因为没有名字，所以也不会跟其他函数发生命名冲突的问题。</p>
<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">扩展</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：面试的时候有可能还会考你用 Lambda 函数来实现一些功能，也就是用一行代码来实现题目要求的功能，例如：用一行代码实现求阶乘的函数，用一行代码实现求最大公约数的函数等。</font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fac = <span class="keyword">lambda</span> x: <span class="built_in">__import__</span>(<span class="string">&#x27;functools&#x27;</span>).reduce(<span class="built_in">int</span>.__mul__, <span class="built_in">range</span>(<span class="number">1</span>, x + <span class="number">1</span>), <span class="number">1</span>)</span><br><span class="line">gcd = <span class="keyword">lambda</span> x, y: y % x <span class="keyword">and</span> gcd(y % x, x) <span class="keyword">or</span> x</span><br></pre></td></tr></table></figure>

<p>Lambda 函数其实最为主要的用途是把一个函数传入另一个高阶函数（如 Python 内置的<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">filter</font>、<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">map</font>等）中来为函数做解耦合，增强函数的灵活性和通用性。下面的例子通过使用<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">filter</font>和<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">map</font>函数，实现了从列表中筛选出奇数并求平方构成新列表的操作，因为用到了高阶函数，过滤和映射数据的规则都是函数的调用者通过另外一个函数传入的，因此这<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">filter</font>和<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">map</font>函数没有跟特定的过滤和映射数据的规则耦合在一起。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">items = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">19</span>]</span><br><span class="line">items = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span>, items)))</span><br><span class="line"><span class="built_in">print</span>(items)    <span class="comment"># [25, 49, 361]</span></span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">扩展</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：用列表的生成式来实现上面的代码会更加简单明了，代码如下所示。</font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">items = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">19</span>]</span><br><span class="line">items = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> items <span class="keyword">if</span> x % <span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(items)    <span class="comment"># [25, 49, 361]</span></span><br></pre></td></tr></table></figure>

<h5 id="题目-006：说说-Python-中的浅拷贝和深拷贝。"><a href="#题目-006：说说-Python-中的浅拷贝和深拷贝。" class="headerlink" title="题目 006：说说 Python 中的浅拷贝和深拷贝。"></a><font style="color:rgb(85, 87, 112);">题目 006：说说 Python 中的浅拷贝和深拷贝。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：这个题目本身出现的频率非常高，但是就题论题而言没有什么技术含量。对于这种面试题，在</font><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">回答的时候一定要让你的答案能够超出面试官的预期</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，这样才能</font><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">获得更好的印象分</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">。所以回答这个题目的要点不仅仅是能够说出浅拷贝和深拷贝的区别，深拷贝的时候可能遇到的两大问题，还要说出 Python 标准库对浅拷贝和深拷贝的支持，然后可以说说列表、字典如何实现拷贝操作以及如何通过序列化和反序列的方式实现深拷贝，最后还可以提到设计模式中的原型模式以及它在项目中的应用。</font></p>
<p>浅拷贝通常只复制对象本身，而深拷贝不仅会复制对象，还会递归的复制对象所关联的对象。深拷贝可能会遇到两个问题：一是一个对象如果直接或间接的引用了自身，会导致无休止的递归拷贝；二是深拷贝可能对原本设计为多个对象共享的数据也进行拷贝。Python 通过<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">copy</font>模块中的<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">copy</font>和<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">deepcopy</font>函数来实现浅拷贝和深拷贝操作，其中<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">deepcopy</font>可以通过<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">memo</font>字典来保存已经拷贝过的对象，从而避免刚才所说的自引用递归问题；此外，可以通过<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">copyreg</font>模块的<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">pickle</font>函数来定制指定类型对象的拷贝行为。</p>
<p><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">deepcopy</font>函数的本质其实就是对象的一次序列化和一次返回序列化，面试题中还考过用自定义函数实现对象的深拷贝操作，显然我们可以使用<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">pickle</font>模块的<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">dumps</font>和<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">loads</font>来做到，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">my_deep_copy = <span class="keyword">lambda</span> obj: pickle.loads(pickle.dumps(obj))</span><br></pre></td></tr></table></figure>

<p>列表的切片操作<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">[:]</font>相当于实现了列表对象的浅拷贝，而字典的<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">copy</font>方法可以实现字典对象的浅拷贝。对象拷贝其实是更为快捷的创建对象的方式。在 Python 中，通过构造器创建对象属于两阶段构造，首先是分配内存空间，然后是初始化。在创建对象时，我们也可以基于“原型”对象来创建新对象，通过对原型对象的拷贝（复制内存）就完成了对象的创建和初始化，这种做法更加高效，这也就是设计模式中的原型模式。在 Python 中，我们可以通过元类的方式来实现原型模式，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrototypeMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;实现原型模式的元类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line">        <span class="comment"># 为对象绑定clone方法来实现对象拷贝</span></span><br><span class="line">        cls.clone = <span class="keyword">lambda</span> <span class="variable language_">self</span>, is_deep=<span class="literal">True</span>: \</span><br><span class="line">        copy.deepcopy(<span class="variable language_">self</span>) <span class="keyword">if</span> is_deep <span class="keyword">else</span> copy.copy(<span class="variable language_">self</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(metaclass=PrototypeMeta):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Person()</span><br><span class="line">p2 = p1.clone()                 <span class="comment"># 深拷贝</span></span><br><span class="line">p3 = p1.clone(is_deep=<span class="literal">False</span>)    <span class="comment"># 浅拷贝</span></span><br></pre></td></tr></table></figure>

<h5 id="题目-007：Python-是如何实现内存管理的？"><a href="#题目-007：Python-是如何实现内存管理的？" class="headerlink" title="题目 007：Python 是如何实现内存管理的？"></a><font style="color:rgb(85, 87, 112);">题目 007：Python 是如何实现内存管理的？</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：当面试官问到这个问题的时候，一个展示自己的机会就摆在面前了。你要先反问面试官：“你说的是官方的 CPython 解释器吗？”。这个反问可以展示出你了解过 Python 解释器的不同的实现版本，而且你也知道面试官想问的是 CPython。当然，很多面试官对不同的 Python 解释器底层实现到底有什么差别也没有概念。所以，</font><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">千万不要觉得面试官一定比你强</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，怀揣着这份自信可以让你更好的完成面试。</font></p>
<p>Python 提供了自动化的内存管理，也就是说内存空间的分配与释放都是由 Python 解释器在运行时自动进行的，自动管理内存功能极大的减轻程序员的工作负担，也能够帮助程序员在一定程度上解决内存泄露的问题。以 CPython 解释器为例，它的内存管理有三个关键点：引用计数、标记清理、分代收集。</p>
<p><strong>引用计数</strong>：对于 CPython 解释器来说，Python 中的每一个对象其实就是<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">PyObject</font>结构体，它的内部有一个名为<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">ob_refcnt</font> 的引用计数器成员变量。程序在运行的过程中<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">ob_refcnt</font>的值会被更新并藉此来反映引用有多少个变量引用到该对象。当对象的引用计数值为 0 时，它的内存就会被释放掉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _object &#123;</span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    struct _typeobject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>

<p>以下情况会导致引用计数加<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">1</font>：</p>
<ul>
<li>对象被创建</li>
<li>对象被引用</li>
<li>对象作为参数传入到一个函数中</li>
<li>对象作为元素存储到一个容器中</li>
</ul>
<p>以下情况会导致引用计数减<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">1</font>：</p>
<ul>
<li>用<font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">del</font>语句显示删除对象引用</li>
<li>对象引用被重新赋值其他对象</li>
<li>一个对象离开它所在的作用域</li>
<li>持有该对象的容器自身被销毁</li>
<li>持有该对象的容器删除该对象</li>
</ul>
<p>可以通过<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">sys</font>模块的<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">getrefcount</font>函数来获得对象的引用计数。引用计数的内存管理方式在遇到循环引用的时候就会出现致命伤，因此需要其他的垃圾回收算法对其进行补充。</p>
<p><strong>标记清理</strong>：CPython 使用了“标记-清理”（Mark and Sweep）算法解决容器类型可能产生的循环引用问题。该算法在垃圾回收时分为两个阶段：标记阶段，遍历所有的对象，如果对象是可达的（被其他对象引用），那么就标记该对象为可达；清除阶段，再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收。CPython 底层维护了两个双端链表，一个链表存放着需要被扫描的容器对象（姑且称之为链表 A），另一个链表存放着临时不可达对象（姑且称之为链表 B）。为了实现“标记-清理”算法，链表中的每个节点除了有记录当前引用计数的<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">ref</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">_count</font>变量外，还有一个<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">gc_ref</font>变量，这个<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">gc_ref</font>是<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">ref</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">_count</font>的一个副本，所以初始值为<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">ref</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">_count</font>的大小。执行垃圾回收时，首先遍历链表 A 中的节点，并且将当前对象所引用的所有对象的<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">gc_ref</font>减<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">1</font>，这一步主要作用是解除循环引用对引用计数的影响。再次遍历链表 A 中的节点，如果节点的<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">gc_ref</font>值为<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">0</font>，那么这个对象就被标记为“暂时不可达”（<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">GC_TENTATIVELY_UNREACHABLE</font>）并被移动到链表 B 中；如果节点的<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">gc_ref</font>不为<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">0</font>，那么这个对象就会被标记为“可达“（<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">GC_REACHABLE</font>），对于”可达“对象，还要递归的将该节点可以到达的节点标记为”可达“；链表 B 中被标记为”可达“的节点要重新放回到链表 A 中。在两次遍历之后，链表 B 中的节点就是需要释放内存的节点。</p>
<p><strong>分代回收</strong>：在循环引用对象的回收中，整个应用程序会被暂停，为了减少应用程序暂停的时间，Python 通过分代回收（空间换时间）的方法提高垃圾回收效率。分代回收的基本思想是：<strong>对象存在的时间越长，是垃圾的可能性就越小，应该尽量不对这样的对象进行垃圾回收</strong>。CPython 将对象分为三种世代分别记为<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">0</font>、<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">1</font>、<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">2</font>，每一个新生对象都在第<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">0</font>代中，如果该对象在一轮垃圾回收扫描中存活下来，那么它将被移到第<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">1</font>代中，存在于第<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">1</font>代的对象将较少的被垃圾回收扫描到；如果在对第<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">1</font>代进行垃圾回收扫描时，这个对象又存活下来，那么它将被移至第 2 代中，在那里它被垃圾回收扫描的次数将会更少。分代回收扫描的门限值可以通过<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">gc</font>模块的<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">get_threshold</font>函数来获得，该函数返回一个三元组，分别表示多少次内存分配操作后会执行<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">0</font>代垃圾回收，多少次<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">0</font>代垃圾回收后会执行<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">1</font>代垃圾回收，多少次<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">1</font>代垃圾回收后会执行<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">2</font>代垃圾回收。需要说明的是，如果执行一次<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">2</font>代垃圾回收，那么比它年轻的代都要执行垃圾回收。如果想修改这几个门限值，可以通过<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">gc</font>模块的<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">set_threshold</font>函数来做到。</p>
<h5 id="题目-008：说一下你对-Python-中迭代器和生成器的理解。"><a href="#题目-008：说一下你对-Python-中迭代器和生成器的理解。" class="headerlink" title="题目 008：说一下你对 Python 中迭代器和生成器的理解。"></a><font style="color:rgb(85, 87, 112);">题目 008：说一下你对 Python 中迭代器和生成器的理解。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：很多人面试者都会写迭代器和生成器，但是却无法准确的解释什么是迭代器和生成器。如果你也有同样的困惑，可以参考下面的回答。</font></p>
<p>迭代器是实现了迭代器协议的对象。跟其他编程语言不通，Python 中没有用于定义协议或表示约定的关键字，像<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">interface</font>、<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">protocol</font>这些单词并不在 Python 语言的关键字列表中。Python 语言通过魔法方法来表示约定，也就是我们所说的协议，而*<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>next</strong></font><em>和</em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>iter</strong></font>*这两个魔法方法就代表了迭代器协议。可以通过<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">for-in</font>循环从迭代器对象中取出值，也可以使用<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">next</font>函数取出迭代器对象中的下一个值。生成器是迭代器的语法升级版本，可以用更为简单的代码来实现一个迭代器。</p>
<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">扩展</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：面试中经常让写生成斐波那契数列的迭代器，大家可以参考下面的代码。</font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="variable language_">self</span>.num = num</span><br><span class="line">        <span class="variable language_">self</span>.a, <span class="variable language_">self</span>.b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="variable language_">self</span>.idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.idx &lt; <span class="variable language_">self</span>.num:</span><br><span class="line">            <span class="variable language_">self</span>.a, <span class="variable language_">self</span>.b = <span class="variable language_">self</span>.b, <span class="variable language_">self</span>.a + <span class="variable language_">self</span>.b</span><br><span class="line">            <span class="variable language_">self</span>.idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.a</span><br><span class="line">        <span class="keyword">raise</span> StopIteration()</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">如果用生成器的语法来改写上面的代码，代码会简单优雅很多。</font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">num</span>):</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        <span class="keyword">yield</span> a</span><br></pre></td></tr></table></figure>

<h5 id="题目-009：正则表达式的-match-方法和-search-方法有什么区别？"><a href="#题目-009：正则表达式的-match-方法和-search-方法有什么区别？" class="headerlink" title="题目 009：正则表达式的 match 方法和 search 方法有什么区别？"></a><font style="color:rgb(85, 87, 112);">题目 009：正则表达式的 match 方法和 search 方法有什么区别？</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：正则表达式是字符串处理的重要工具，所以也是面试中经常考察的知识点。在 Python 中，使用正则表达式有两种方式，一种是直接调用</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">re</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">模块中的函数，传入正则表达式和需要处理的字符串；一种是先通过</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">re</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">模块的</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">compile</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">函数创建正则表达式对象，然后再通过对象调用方法并传入需要处理的字符串。</font><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">如果一个正则表达式被频繁的使用，我们推荐用</font>**</strong><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">re.</font>*<strong>*<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">compile</font>**</strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">函数创建正则表达式对象，这样会减少频繁编译同一个正则表达式所造成的开销</font>**<font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">。</font></p>
<p><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">match</font>方法是从字符串的起始位置进行正则表达式匹配，返回<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">Match</font>对象或 None。<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">search</font>方法会扫描整个字符串来找寻匹配的模式，同样也是返回 Match 对象或 None。</p>
<h5 id="题目-010：下面这段代码的执行结果是什么。"><a href="#题目-010：下面这段代码的执行结果是什么。" class="headerlink" title="题目 010：下面这段代码的执行结果是什么。"></a><font style="color:rgb(85, 87, 112);">题目 010：下面这段代码的执行结果是什么。</font></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">multiply</span>():</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">lambda</span> x: i * x <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>([m(<span class="number">100</span>) <span class="keyword">for</span> m <span class="keyword">in</span> multiply()])</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[300, 300, 300, 300]</span><br></pre></td></tr></table></figure>

<p>上面代码的运行结果很容易被误判为<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">[0, 100, 200, 300]</font>。首先需要注意的是<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">multiply</font>函数用生成式语法返回了一个列表，列表中保存了 4 个 Lambda 函数，这 4 个 Lambda 函数会返回传入的参数乘以<font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">i</font>的结果。需要注意的是这里有闭包（closure）现象，<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">multiply</font>函数中的局部变量<font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">i</font>的生命周期被延展了，由于<font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">i</font>最终的值是<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">3</font>，所以通过<font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">m</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">(</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">100</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">)</font>调列表中的 Lambda 函数时会返回<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">300</font>，而且 4 个调用都是如此。</p>
<p>如果想得到<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">[0, 100, 200, 300]</font>这个结果，可以按照下面几种方式来修改<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">multiply</font>函数。</p>
<p>方法一：使用生成器，让函数获得<font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">i</font>的当前值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">multiply</span>():</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">lambda</span> x: i * x <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>([m(<span class="number">100</span>) <span class="keyword">for</span> m <span class="keyword">in</span> multiply()])</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">multiply</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">lambda</span> x: x * i</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>([m(<span class="number">100</span>) <span class="keyword">for</span> m <span class="keyword">in</span> multiply()])</span><br></pre></td></tr></table></figure>

<p>方法二：使用偏函数，彻底避开闭包。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> __mul__</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiply</span>():</span><br><span class="line">    <span class="keyword">return</span> [partial(__mul__, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>([m(<span class="number">100</span>) <span class="keyword">for</span> m <span class="keyword">in</span> multiply()])</span><br></pre></td></tr></table></figure>

<h5 id="题目-011：Python-中为什么没有函数重载？"><a href="#题目-011：Python-中为什么没有函数重载？" class="headerlink" title="题目 011：Python 中为什么没有函数重载？"></a><font style="color:rgb(85, 87, 112);">题目 011：Python 中为什么没有函数重载？</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：C++、Java、C#等诸多编程语言都支持函数重载，所谓函数重载指的是在同一个作用域中有多个同名函数，它们拥有不同的参数列表（参数个数不同或参数类型不同或二者皆不同），可以相互区分。重载也是一种多态性，因为通常是在编译时通过参数的个数和类型来确定到底调用哪个重载函数，所以也被称为编译时多态性或者叫前绑定。这个问题的潜台词其实是问面试者是否有其他编程语言的经验，是否理解 Python 是动态类型语言，是否知道 Python 中函数的可变参数、关键字参数这些概念。</font></p>
<p>首先 Python 是解释型语言，函数重载现象通常出现在编译型语言中。其次 Python 是动态类型语言，函数的参数没有类型约束，也就无法根据参数类型来区分重载。再者 Python 中函数的参数可以有默认值，可以使用可变参数和关键字参数，因此即便没有函数重载，也要可以让一个函数根据调用者传入的参数产生不同的行为。</p>
<h5 id="题目-012：用-Python-代码实现-Python-内置函数-max。"><a href="#题目-012：用-Python-代码实现-Python-内置函数-max。" class="headerlink" title="题目 012：用 Python 代码实现 Python 内置函数 max。"></a><font style="color:rgb(85, 87, 112);">题目 012：用 Python 代码实现 Python 内置函数 max。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：这个题目看似简单，但实际上还是比较考察面试者的功底。因为 Python 内置的</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">max</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">函数既可以传入可迭代对象找出最大，又可以传入两个或多个参数找出最大；最为关键的是还可以通过命名关键字参数</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">key</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">来指定一个用于元素比较的函数，还可以通过</font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">default</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">命名关键字参数来指定当可迭代对象为空时返回的默认值。</font></p>
<p>下面的代码仅供参考：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_max</span>(<span class="params">*args, key=<span class="literal">None</span>, default=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取可迭代对象中最大的元素或两个及以上实参中最大的元素</span></span><br><span class="line"><span class="string">    :param args: 一个可迭代对象或多个元素</span></span><br><span class="line"><span class="string">    :param key: 提取用于元素比较的特征值的函数，默认为None</span></span><br><span class="line"><span class="string">    :param default: 如果可迭代对象为空则返回该默认值，如果没有给默认值则引发ValueError异常</span></span><br><span class="line"><span class="string">    :return: 返回可迭代对象或多个元素中的最大元素</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">len</span>(args[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> default:</span><br><span class="line">            <span class="keyword">return</span> default</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;max() arg is an empty sequence&#x27;</span>)</span><br><span class="line">    items = args[<span class="number">0</span>] <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">1</span> <span class="keyword">else</span> args</span><br><span class="line">    max_elem, max_value = items[<span class="number">0</span>], items[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> key:</span><br><span class="line">        max_value = key(max_value)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        value = item</span><br><span class="line">        <span class="keyword">if</span> key:</span><br><span class="line">            value = key(item)</span><br><span class="line">        <span class="keyword">if</span> value &gt; max_value:</span><br><span class="line">            max_elem, max_value = item, value</span><br><span class="line">    <span class="keyword">return</span> max_elem</span><br></pre></td></tr></table></figure>

<h5 id="题目-013：写一个函数统计传入的列表中每个数字出现的次数并返回对应的字典。"><a href="#题目-013：写一个函数统计传入的列表中每个数字出现的次数并返回对应的字典。" class="headerlink" title="题目 013：写一个函数统计传入的列表中每个数字出现的次数并返回对应的字典。"></a><font style="color:rgb(85, 87, 112);">题目 013：写一个函数统计传入的列表中每个数字出现的次数并返回对应的字典。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：送人头的题目，不解释。</font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_letters</span>(<span class="params">items</span>):</span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(item, (<span class="built_in">int</span>, <span class="built_in">float</span>)):</span><br><span class="line">            result[item] = result.get(item, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>也可以直接使用 Python 标准库中<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">collections</font>模块的<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">Counter</font>类来解决这个问题，<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">Counter</font>是<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">dict</font>的子类，它会将传入的序列中的每个元素作为键，元素出现的次数作为值来构造字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_letters</span>(<span class="params">items</span>):</span><br><span class="line">    counter = Counter(items)</span><br><span class="line">    <span class="keyword">return</span> &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> counter.items() \</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(key, (<span class="built_in">int</span>, <span class="built_in">float</span>))&#125;</span><br></pre></td></tr></table></figure>

<h5 id="题目-014：使用-Python-代码实现遍历一个文件夹的操作。"><a href="#题目-014：使用-Python-代码实现遍历一个文件夹的操作。" class="headerlink" title="题目 014：使用 Python 代码实现遍历一个文件夹的操作。"></a><font style="color:rgb(85, 87, 112);">题目 014：使用 Python 代码实现遍历一个文件夹的操作。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：基本也是送人头的题目，只要用过</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">os</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">模块就应该知道怎么做。</font></p>
<p>Python 标准库<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">os</font>模块的<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">walk</font>函数提供了遍历一个文件夹的功能，它返回一个生成器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">g = os.walk(<span class="string">&#x27;/Users/Hao/Downloads/&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> path, dir_list, file_list <span class="keyword">in</span> g:</span><br><span class="line">    <span class="keyword">for</span> dir_name <span class="keyword">in</span> dir_list:</span><br><span class="line">        <span class="built_in">print</span>(os.path.join(path, dir_name))</span><br><span class="line">    <span class="keyword">for</span> file_name <span class="keyword">in</span> file_list:</span><br><span class="line">        <span class="built_in">print</span>(os.path.join(path, file_name))</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">说明</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">os</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">path</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">模块提供了很多进行路径操作的工具函数，在项目开发中也是经常会用到的。如果题目明确要求不能使用</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">os</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.walk</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">函数，那么可以使用</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">os</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.listdir</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">函数来获取指定目录下的文件和文件夹，然后再通过循环遍历用</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">os</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.isdir</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">函数判断哪些是文件夹，对于文件夹可以通过</font><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">递归调用</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">进行遍历，这样也可以实现遍历一个文件夹的操作。</font></p>
<h5 id="题目-015：现有-2-元、3-元、5-元共三种面额的货币，如果需要找零-99-元，一共有多少种找零的方式？"><a href="#题目-015：现有-2-元、3-元、5-元共三种面额的货币，如果需要找零-99-元，一共有多少种找零的方式？" class="headerlink" title="题目 015：现有 2 元、3 元、5 元共三种面额的货币，如果需要找零 99 元，一共有多少种找零的方式？"></a><font style="color:rgb(85, 87, 112);">题目 015：现有 2 元、3 元、5 元共三种面额的货币，如果需要找零 99 元，一共有多少种找零的方式？</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：还有一个非常类似的题目：“一个小朋友走楼梯，一次可以走 1 个台阶、2 个台阶或 3 个台阶，问走完 10 个台阶一共有多少种走法？”，这两个题目的思路是一样，如果用递归函数来写的话非常简单。</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from functools import lru_cache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@lru_cache()</span><br><span class="line">def change_money(total):</span><br><span class="line">    if total == 0:</span><br><span class="line">        return 1</span><br><span class="line">    if total &lt; 0:</span><br><span class="line">        return 0</span><br><span class="line">    return change_money(total - 2) + change_money(total - 3) + \</span><br><span class="line">        change_money(total - 5)</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">说明</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：在上面的代码中，我们用</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">lru_cache</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">装饰器装饰了递归函数</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">change_money</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，如果不做这个优化，上面代码的渐近时间复杂度将会是</font><img src="https://cdn.nlark.com/yuque/0/2024/png/38881094/1710778212608-15021bec-58e2-4a1c-bbce-648755adb08d.png"><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，而如果参数</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">total</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">的值是</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">99</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，这个运算量是非常巨大的。</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">lru_cache</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">装饰器会缓存函数的执行结果，这样就可以减少重复运算所造成的开销，这是空间换时间的策略，也是动态规划的编程思想。</font></p>
<h5 id="题目-016：写一个函数，给定矩阵的阶数n，输出一个螺旋式数字矩阵。"><a href="#题目-016：写一个函数，给定矩阵的阶数n，输出一个螺旋式数字矩阵。" class="headerlink" title="题目 016：写一个函数，给定矩阵的阶数&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;n&lt;/font&gt;，输出一个螺旋式数字矩阵。"></a><font style="color:rgb(85, 87, 112);">题目 016：写一个函数，给定矩阵的阶数</font><code>&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;n&lt;/font&gt;</code><font style="color:rgb(85, 87, 112);">，输出一个螺旋式数字矩阵。</font></h5><p><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">例如：n &#x3D; 2，返回：</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">例如：n &#x3D; 3，返回：</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">8 9 4</span><br><span class="line">7 6 5</span><br></pre></td></tr></table></figure>

<p>这个题目本身并不复杂，下面的代码仅供参考。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">show_spiral_matrix</span>(<span class="params">n</span>):</span><br><span class="line">    matrix = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    row, col = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    num, direction = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> num &lt;= n ** <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> matrix[row][col] == <span class="number">0</span>:</span><br><span class="line">            matrix[row][col] = num</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> direction == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> col &lt; n - <span class="number">1</span> <span class="keyword">and</span> matrix[row][col + <span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">                col += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                direction += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> direction == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> row &lt; n - <span class="number">1</span> <span class="keyword">and</span> matrix[row + <span class="number">1</span>][col] == <span class="number">0</span>:</span><br><span class="line">                row += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                direction += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> direction == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> col &gt; <span class="number">0</span> <span class="keyword">and</span> matrix[row][col - <span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">                col -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                direction += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> row &gt; <span class="number">0</span> <span class="keyword">and</span> matrix[row - <span class="number">1</span>][col] == <span class="number">0</span>:</span><br><span class="line">                row -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                direction += <span class="number">1</span></span><br><span class="line">        direction %= <span class="number">4</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> matrix:</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> x:</span><br><span class="line">            <span class="built_in">print</span>(y, end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>

<h5 id="题目-017：阅读下面的代码，写出程序的运行结果。"><a href="#题目-017：阅读下面的代码，写出程序的运行结果。" class="headerlink" title="题目 017：阅读下面的代码，写出程序的运行结果。"></a><font style="color:rgb(85, 87, 112);">题目 017：阅读下面的代码，写出程序的运行结果。</font></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> items <span class="keyword">if</span> i &gt; <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> items <span class="keyword">if</span> i % <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>([(x, y) <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="string">&#x27;abcd&#x27;</span>, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))])</span><br><span class="line"><span class="built_in">print</span>(&#123;x: <span class="string">f&#x27;item<span class="subst">&#123;x ** <span class="number">2</span>&#125;</span>&#x27;</span> <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(&#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;hello world&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abcdefg&#x27;</span>&#125;))</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：</font><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">生成式（推导式）属于 Python 的特色语法之一，几乎是面试必考内容</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">。Python 中通过生成式字面量语法，可以创建出列表、集合、字典。</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[3, 4]</span><br><span class="line">[1, 3]</span><br><span class="line">[(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 3), (&#x27;d&#x27;, 4)]</span><br><span class="line">&#123;2: &#x27;item4&#x27;, 4: &#x27;item16&#x27;, 6: &#x27;item36&#x27;&#125;</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<h5 id="题目-018：说出下面代码的运行结果。"><a href="#题目-018：说出下面代码的运行结果。" class="headerlink" title="题目 018：说出下面代码的运行结果。"></a><font style="color:rgb(85, 87, 112);">题目 018：说出下面代码的运行结果。</font></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>:</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child1</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child2</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Parent.x, Child1.x, Child2.x)</span><br><span class="line">Child1.x = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(Parent.x, Child1.x, Child2.x)</span><br><span class="line">Parent.x = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(Parent.x, Child1.x, Child2.x)</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：运行上面的代码首先输出</font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">1</font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">1</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">1</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，这一点大家应该没有什么疑问。接下来，通过</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">Child1.x</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">&#x3D;</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">2</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">给类</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">Child1</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">重新绑定了属性</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">x</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">并赋值为</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">2</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，所以</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">Child</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">1</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.</font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">x</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">会输出</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">2</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，而</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">Parent</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">和</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">Child2</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">并不受影响。执行</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">Parent.x</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">&#x3D;</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">3</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">会重新给</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">Parent</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">类的</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">x</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">属性赋值为</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">3</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，由于</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">Child2</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">的</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">x</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">属性继承自</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">Parent</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，所以</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">Child</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">2</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.</font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">x</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">的值也是</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">3</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">；而之前我们为</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">Child1</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">重新绑定了</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">x</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">属性，那么它的</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">x</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">属性值不会受到</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">Parent.x</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">&#x3D;</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">3</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">的影响，还是之前的值</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">2</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">。</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 1 1</span><br><span class="line">1 2 1</span><br><span class="line">3 2 3</span><br></pre></td></tr></table></figure>

<h5 id="题目-19：说说你用过-Python-标准库中的哪些模块。"><a href="#题目-19：说说你用过-Python-标准库中的哪些模块。" class="headerlink" title="题目 19：说说你用过 Python 标准库中的哪些模块。"></a><font style="color:rgb(85, 87, 112);">题目 19：说说你用过 Python 标准库中的哪些模块。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：Python 标准库中的模块非常多，建议大家根据自己过往的项目经历来介绍你用过的标准库和三方库，因为这些是你最为熟悉的，经得起面试官深挖的。</font></p>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:rgb(79, 79, 79);">模块名</font></strong></th>
<th align="left"><strong><font style="color:rgb(79, 79, 79);">介绍</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><font style="color:rgb(79, 79, 79);">sys</font></td>
<td align="left"><font style="color:rgb(79, 79, 79);">跟 Python 解释器相关的变量和函数，例如：</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">sys.</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">version</font><font style="color:rgb(79, 79, 79);">、</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">sys.</font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">exit</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">()</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(79, 79, 79);">os</font></td>
<td align="left"><font style="color:rgb(79, 79, 79);">和操作系统相关的功能，例如：</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">os.listdir</font><em><font style="color:rgb(92, 99, 112);background-color:rgb(40, 44, 52);">()</font></em><font style="color:rgb(79, 79, 79);">、</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">os</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">remove</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">()</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(79, 79, 79);">re</font></td>
<td align="left"><font style="color:rgb(79, 79, 79);">和正则表达式相关的功能，例如：</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">re.compile</font><em><font style="color:rgb(92, 99, 112);background-color:rgb(40, 44, 52);">()</font></em><font style="color:rgb(79, 79, 79);">、</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">re.search</font><em><font style="color:rgb(92, 99, 112);background-color:rgb(40, 44, 52);">()</font></em></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(79, 79, 79);">math</font></td>
<td align="left"><font style="color:rgb(79, 79, 79);">和数学运算相关的功能，例如：</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">math</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">pi</font><font style="color:rgb(79, 79, 79);">、</font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">math</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.e</font><font style="color:rgb(79, 79, 79);">、</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">math</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">cos</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(79, 79, 79);">logging</font></td>
<td align="left"><font style="color:rgb(79, 79, 79);">和日志系统相关的类和函数，例如：</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">logging.Logger</font><font style="color:rgb(79, 79, 79);">、</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">logging.</font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">Handler</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(79, 79, 79);">json &#x2F; pickle</font></td>
<td align="left"><font style="color:rgb(79, 79, 79);">实现对象序列化和反序列的模块，例如：</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">json</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.loads</font><font style="color:rgb(79, 79, 79);">、</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">json</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.dumps</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(79, 79, 79);">hashlib</font></td>
<td align="left"><font style="color:rgb(79, 79, 79);">封装了多种哈希摘要算法的模块，例如：</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">hashlib.</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">md5</font><font style="color:rgb(79, 79, 79);">、</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">hashlib.sha1</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(79, 79, 79);">urllib</font></td>
<td align="left"><font style="color:rgb(79, 79, 79);">包含了和 URL 相关的子模块，例如：</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">urllib.</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">request</font><font style="color:rgb(79, 79, 79);">、</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">urllib.</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">parse</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(79, 79, 79);">itertools</font></td>
<td align="left"><font style="color:rgb(79, 79, 79);">提供各种迭代器的模块，例如：</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">itertools.</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">cycle</font><font style="color:rgb(79, 79, 79);">、</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">itertools.</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">product</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(79, 79, 79);">functools</font></td>
<td align="left"><font style="color:rgb(79, 79, 79);">函数相关工具模块，例如：</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">functools.</font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">partial</font><font style="color:rgb(79, 79, 79);">、</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">functools.lru_cache</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(79, 79, 79);">collections &#x2F; heapq</font></td>
<td align="left"><font style="color:rgb(79, 79, 79);">封装了常用数据结构和算法的模块，例如：</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">collections.deque</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(79, 79, 79);">threading &#x2F; multiprocessing</font></td>
<td align="left"><font style="color:rgb(79, 79, 79);">多线程&#x2F;多进程相关类和函数的模块，例如：</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">threading.</font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">Thread</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(79, 79, 79);">concurrent.futures &#x2F; asyncio</font></td>
<td align="left"><font style="color:rgb(79, 79, 79);">并发编程&#x2F;异步编程相关的类和函数的模块，例如：</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">ThreadPoolExecutor</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(79, 79, 79);">base64</font></td>
<td align="left"><font style="color:rgb(79, 79, 79);">提供 BASE-64 编码相关函数的模块，例如：</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">bas64.</font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">encode</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(79, 79, 79);">csv</font></td>
<td align="left"><font style="color:rgb(79, 79, 79);">和读写 CSV 文件相关的模块，例如：</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">csv</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.reader</font><font style="color:rgb(79, 79, 79);">、</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">csv</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.writer</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(79, 79, 79);">profile &#x2F; cProfile &#x2F; pstats</font></td>
<td align="left"><font style="color:rgb(79, 79, 79);">和代码性能剖析相关的模块，例如：</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">cProfile.</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">run</font><font style="color:rgb(79, 79, 79);">、</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">pstats.Stats</font></td>
</tr>
<tr>
<td align="left"><font style="color:rgb(79, 79, 79);">unittest</font></td>
<td align="left"><font style="color:rgb(79, 79, 79);">和单元测试相关的模块，例如：</font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">unittest</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.TestCase</font></td>
</tr>
</tbody></table>
<h5 id="题目-20：-init-和-new-方法有什么区别？"><a href="#题目-20：-init-和-new-方法有什么区别？" class="headerlink" title="题目 20：&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;__&lt;/font&gt;**&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;init__&lt;/font&gt;**和**&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;__new__&lt;/font&gt;**方法有什么区别？"></a><font style="color:rgb(85, 87, 112);">题目 20：</font><code>&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;__&lt;/font&gt;**&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;init__&lt;/font&gt;**</code><strong><font style="color:rgb(85, 87, 112);">和</font></strong><code>**&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;__new__&lt;/font&gt;**</code><font style="color:rgb(85, 87, 112);">方法有什么区别？</font></h5><p>Python 中调用构造器创建对象属于两阶段构造过程，首先执行*<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>new</strong></font><em>方法获得保存对象所需的内存空间，再通过</em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>init</strong></font><em>执行对内存空间数据的填充（对象属性的初始化）。</em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>new</strong></font><em>方法的返回值是创建好的 Python 对象（的引用），而</em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>init</strong></font><em>方法的第一个参数就是这个对象（的引用），所以在</em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>init</strong></font><em>中可以完成对对象的初始化操作。</em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>new</strong></font><em>是类方法，它的第一个参数是类，</em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>init</strong></font>*是对象方法，它的第一个参数是对象。</p>
<h5 id="题目-21：输入年月日，判断这个日期是这一年的第几天。"><a href="#题目-21：输入年月日，判断这个日期是这一年的第几天。" class="headerlink" title="题目 21：输入年月日，判断这个日期是这一年的第几天。"></a><font style="color:rgb(85, 87, 112);">题目 21：输入年月日，判断这个日期是这一年的第几天。</font></h5><p>方法一：不使用标准库中的模块和函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_leap_year</span>(<span class="params">year</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;判断指定的年份是不是闰年，平年返回False，闰年返回True&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> year % <span class="number">4</span> == <span class="number">0</span> <span class="keyword">and</span> year % <span class="number">100</span> != <span class="number">0</span> <span class="keyword">or</span> year % <span class="number">400</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">which_day</span>(<span class="params">year, month, date</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算传入的日期是这一年的第几天&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 用嵌套的列表保存平年和闰年每个月的天数</span></span><br><span class="line">    days_of_month = [</span><br><span class="line">        [<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>],</span><br><span class="line">        [<span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>]</span><br><span class="line">    ]</span><br><span class="line">    days = days_of_month[is_leap_year(year)][:month - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(days) + date</span><br></pre></td></tr></table></figure>

<p>方法二：使用标准库中的<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">datetime</font>模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">which_day</span>(<span class="params">year, month, date</span>):</span><br><span class="line">    end = datetime.date(year, month, date)</span><br><span class="line">    start = datetime.date(year, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> (end - start).days + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h5 id="题目-22：平常工作中用什么工具进行静态代码分析。"><a href="#题目-22：平常工作中用什么工具进行静态代码分析。" class="headerlink" title="题目 22：平常工作中用什么工具进行静态代码分析。"></a><font style="color:rgb(85, 87, 112);">题目 22：平常工作中用什么工具进行静态代码分析。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：静态代码分析工具可以从代码中提炼出各种静态属性，这使得开发者可以对代码的复杂性、可维护性和可读性有更好的了解，这里所说的静态属性包括：</font></p>
<ol>
<li><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">代码是否符合编码规范，例如：PEP-8。</font></li>
<li><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">代码中潜在的问题，包括：语法错误、缩进问题、导入缺失、变量覆盖等。</font></li>
<li><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">代码中的坏味道。</font></li>
<li><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">代码的复杂度。</font></li>
<li><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">代码的逻辑问题。</font></li>
</ol>
<p>工作中静态代码分析主要用到的是 Pylint 和 Flake8。Pylint 可以检查出代码错误、坏味道、不规范的代码等问题，较新的版本中还提供了代码复杂度统计数据，可以生成检查报告。Flake8 封装了 Pyflakes（检查代码逻辑错误）、McCabe（检查代码复杂性）和 Pycodestyle（检查代码是否符合 PEP-8 规范）工具，它可以执行这三个工具提供的检查。</p>
<h5 id="题目-23：说一下你知道的-Python-中的魔术方法。"><a href="#题目-23：说一下你知道的-Python-中的魔术方法。" class="headerlink" title="题目 23：说一下你知道的 Python 中的魔术方法。"></a><font style="color:rgb(85, 87, 112);">题目 23：说一下你知道的 Python 中的魔术方法。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：魔术方法也称为魔法方法，是 Python 中的特色语法，也是面试中的高频问题。</font></p>
<table>
<thead>
<tr>
<th align="left"><strong><font style="color:rgb(79, 79, 79);">魔术方法</font></strong></th>
<th align="left"><strong><font style="color:rgb(79, 79, 79);">作用</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>new</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>init</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>del</strong></font></em></td>
<td align="left"><font style="color:rgb(79, 79, 79);">创建和销毁对象相关</font></td>
</tr>
<tr>
<td align="left"><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>add</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>sub</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>mul</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>div</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>floordiv</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>mod</strong></font></em></td>
<td align="left"><font style="color:rgb(79, 79, 79);">算术运算符相关</font></td>
</tr>
<tr>
<td align="left"><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>eq</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>ne</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>lt</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>gt</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>le</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>ge</strong></font></em></td>
<td align="left"><font style="color:rgb(79, 79, 79);">关系运算符相关</font></td>
</tr>
<tr>
<td align="left"><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>pos</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>neg</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>invert</strong></font></em></td>
<td align="left"><font style="color:rgb(79, 79, 79);">一元运算符相关</font></td>
</tr>
<tr>
<td align="left"><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>lshift</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>rshift</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>and</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>or</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>xor</strong></font></em></td>
<td align="left"><font style="color:rgb(79, 79, 79);">位运算相关</font></td>
</tr>
<tr>
<td align="left"><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>enter</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>exit</strong></font></em></td>
<td align="left"><font style="color:rgb(79, 79, 79);">上下文管理器协议</font></td>
</tr>
<tr>
<td align="left"><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>iter</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>next</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>reversed</strong></font></em></td>
<td align="left"><font style="color:rgb(79, 79, 79);">迭代器协议</font></td>
</tr>
<tr>
<td align="left"><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>int</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>long</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>float</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>oct</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>hex</strong></font></em></td>
<td align="left"><font style="color:rgb(79, 79, 79);">类型&#x2F;进制转换相关</font></td>
</tr>
<tr>
<td align="left"><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>str</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>repr</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>hash</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>dir</strong></font></em></td>
<td align="left"><font style="color:rgb(79, 79, 79);">对象表述相关</font></td>
</tr>
<tr>
<td align="left"><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>len</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>getitem</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>setitem</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>contains</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>missing</strong></font></em></td>
<td align="left"><font style="color:rgb(79, 79, 79);">序列相关</font></td>
</tr>
<tr>
<td align="left"><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>copy</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>deepcopy</strong></font></em></td>
<td align="left"><font style="color:rgb(79, 79, 79);">对象拷贝相关</font></td>
</tr>
<tr>
<td align="left"><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>call</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>setattr</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>getattr</strong></font></em><font style="color:rgb(79, 79, 79);">、</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>delattr</strong></font></em></td>
<td align="left"><font style="color:rgb(79, 79, 79);">其他魔术方法</font></td>
</tr>
</tbody></table>
<h5 id="题目-24：函数参数-arg-和-kwargs分别代表什么？"><a href="#题目-24：函数参数-arg-和-kwargs分别代表什么？" class="headerlink" title="题目 24：函数参数_&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;arg&lt;/font&gt;_和&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;*kwargs&lt;/font&gt;分别代表什么？"></a><font style="color:rgb(85, 87, 112);">题目 24：函数参数</font><code>_&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;arg&lt;/font&gt;_</code><em><font style="color:rgb(85, 87, 112);">和</font></em><code>&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;*kwargs&lt;/font&gt;</code><font style="color:rgb(85, 87, 112);">分别代表什么？</font></h5><p>Python 中，函数的参数分为位置参数、可变参数、关键字参数、命名关键字参数。*<font style="color:rgb(92, 99, 112);background-color:rgb(40, 44, 52);">*args</font><em>代表可变参数，可以接收<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">0</font>个或任意多个参数，当不确定调用者会传入多少个位置参数时，就可以使用可变参数，它会将传入的参数打包成一个元组。</em><font style="color:rgb(92, 99, 112);background-color:rgb(40, 44, 52);">**kwargs</font><em>代表关键字参数，可以接收用<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">参数名</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">&#x3D;</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">参数值</font>的方式传入的参数，传入的参数的会打包成一个字典。定义函数时如果同时使用</em><font style="color:rgb(92, 99, 112);background-color:rgb(40, 44, 52);">*args</font><em>和</em><font style="color:rgb(92, 99, 112);background-color:rgb(40, 44, 52);">**kwargs</font>*，那么函数可以接收任意参数。</p>
<h5 id="题目-25：写一个记录函数执行时间的装饰器。"><a href="#题目-25：写一个记录函数执行时间的装饰器。" class="headerlink" title="题目 25：写一个记录函数执行时间的装饰器。"></a><font style="color:rgb(85, 87, 112);">题目 25：写一个记录函数执行时间的装饰器。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：高频面试题，也是最简单的装饰器，面试者</font><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">必须要掌握的内容</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">。</font></p>
<p>方法一：用函数实现装饰器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">record_time</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start = time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;func.__name__&#125;</span>执行时间: <span class="subst">&#123;time() - start&#125;</span>秒&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p>方法二：用类实现装饰器。类有*<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>call</strong></font>*魔术方法，该类对象就是可调用对象，可以当做装饰器来使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Record</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, func</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            start = time()</span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;func.__name__&#125;</span>执行时间: <span class="subst">&#123;time() - start&#125;</span>秒&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">说明</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：装饰器可以用来装饰类或函数，为其提供额外的能力，属于设计模式中的</font><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">代理模式</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">。</font></p>
<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">扩展</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：</font><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">装饰器本身也可以参数化</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，例如上面的例子中，如果不希望在终端中显示函数的执行时间而是希望由调用者来决定如何输出函数的执行时间，可以通过参数化装饰器的方式来做到，代码如下所示。</font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">record_time</span>(<span class="params">output</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;可以参数化的装饰器&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorate</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            start = time()</span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">            output(func.__name__, time() - start)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorate</span><br></pre></td></tr></table></figure>

<h5 id="题目-26：什么是鸭子类型（duck-typing）？"><a href="#题目-26：什么是鸭子类型（duck-typing）？" class="headerlink" title="题目 26：什么是鸭子类型（duck typing）？"></a><font style="color:rgb(85, 87, 112);">题目 26：什么是鸭子类型（duck typing）？</font></h5><p>鸭子类型是动态类型语言判断一个对象是不是某种类型时使用的方法，也叫做鸭子判定法。简单的说，鸭子类型是指判断一只鸟是不是鸭子，我们只关心它游泳像不像鸭子、叫起来像不像鸭子、走路像不像鸭子就足够了。换言之，如果对象的行为跟我们的预期是一致的（能够接受某些消息），我们就认定它是某种类型的对象。</p>
<p>在 Python 语言中，有很多 bytes-like 对象（如：<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">bytes</font>、<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">bytearray</font>、<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">array</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.</font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">array</font>、<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">memoryview</font>）、file-like 对象（如：<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">StringIO</font>、<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">BytesIO</font>、<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">GzipFile</font>、<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">socket</font>）、path-like 对象（如：<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">str</font>、<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">bytes</font>），其中 file-like 对象都能支持<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">read</font>和<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">write</font>操作，可以像文件一样读写，这就是所谓的对象有鸭子的行为就可以判定为鸭子的判定方法。再比如 Python 中列表的<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">extend</font>方法，它需要的参数并不一定要是列表，只要是可迭代对象就没有问题。</p>
<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">说明</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：动态语言的鸭子类型使得设计模式的应用被大大简化。</font></p>
<h5 id="题目-27：说一下-Python-中变量的作用域。"><a href="#题目-27：说一下-Python-中变量的作用域。" class="headerlink" title="题目 27：说一下 Python 中变量的作用域。"></a><font style="color:rgb(85, 87, 112);">题目 27：说一下 Python 中变量的作用域。</font></h5><p>Python 中有四种作用域，分别是局部作用域（<strong>L</strong>ocal）、嵌套作用域（<strong>E</strong>mbedded）、全局作用域（<strong>G</strong>lobal）、内置作用域（<strong>B</strong>uilt-in），搜索一个标识符时，会按照<strong>LEGB</strong>的顺序进行搜索，如果所有的作用域中都没有找到这个标识符，就会引发<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">NameError</font>异常。</p>
<h5 id="题目-28：说一下你对闭包的理解。"><a href="#题目-28：说一下你对闭包的理解。" class="headerlink" title="题目 28：说一下你对闭包的理解。"></a><font style="color:rgb(85, 87, 112);">题目 28：说一下你对闭包的理解。</font></h5><p>闭包是支持一等函数的编程语言（Python、JavaScript 等）中实现词法绑定的一种技术。当捕捉闭包的时候，它的自由变量（在函数外部定义但在函数内部使用的变量）会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。简单的说，可以将闭包理解为<strong>能够读取其他函数内部变量的函数</strong>。正在情况下，函数的局部变量在函数调用结束之后就结束了生命周期，但是<strong>闭包使得局部变量的生命周期得到了延展</strong>。使用闭包的时候需要注意，闭包会使得函数中创建的对象不会被垃圾回收，可能会导致很大的内存开销，所以<strong>闭包一定不能滥用</strong>。</p>
<h5 id="题目-29：说一下-Python-中的多线程和多进程的应用场景和优缺点。"><a href="#题目-29：说一下-Python-中的多线程和多进程的应用场景和优缺点。" class="headerlink" title="题目 29：说一下 Python 中的多线程和多进程的应用场景和优缺点。"></a><font style="color:rgb(85, 87, 112);">题目 29：说一下 Python 中的多线程和多进程的应用场景和优缺点。</font></h5><p>线程是操作系统分配 CPU 的基本单位，进程是操作系统分配内存的基本单位。通常我们运行的程序会包含一个或多个进程，而每个进程中又包含一个或多个线程。多线程的优点在于多个线程可以共享进程的内存空间，所以线程间的通信非常容易实现；但是如果使用官方的 CPython 解释器，多线程受制于 GIL（全局解释器锁），并不能利用 CPU 的多核特性，这是一个很大的问题。使用多进程可以充分利用 CPU 的多核特性，但是进程间通信相对比较麻烦，需要使用 IPC 机制（管道、套接字等）。</p>
<p>多线程适合那些会花费大量时间在 I&#x2F;O 操作上，但没有太多并行计算需求且不需占用太多内存的 I&#x2F;O 密集型应用。多进程适合执行计算密集型任务（如：视频编码解码、数据处理、科学计算等）、可以分解为多个并行子任务并能合并子任务执行结果的任务以及在内存使用方面没有任何限制且不强依赖于 I&#x2F;O 操作的任务。</p>
<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">扩展</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：Python 中实现并发编程通常有多线程、多进程和异步编程三种选择。异步编程实现了协作式并发，通过多个相互协作的子程序的用户态切换，实现对 CPU 的高效利用，这种方式也是非常适合 I&#x2F;O 密集型应用的。</font></p>
<h5 id="题目-30：说一下-Python-2-和-Python-3-的区别。"><a href="#题目-30：说一下-Python-2-和-Python-3-的区别。" class="headerlink" title="题目 30：说一下 Python 2 和 Python 3 的区别。"></a><font style="color:rgb(85, 87, 112);">题目 30：说一下 Python 2 和 Python 3 的区别。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：这种问题千万不要背所谓的参考答案，说一些自己最熟悉的就足够了。</font></p>
<ol>
<li>Python 2 中的<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">print</font>和<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">exec</font>都是关键字，在 Python 3 中变成了函数。</li>
<li>Python 3 中没有<font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">long</font>类型，整数都是<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">int</font>类型。</li>
<li>Python 2 中的不等号<font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">&lt;</font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">&gt;</font>在 Python 3 中被废弃，统一使用<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">!&#x3D;</font>。</li>
<li>Python 2 中的<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">xrange</font>函数在 Python 3 中被<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">range</font>函数取代。</li>
<li>Python 3 对 Python 2 中不安全的<font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">input</font>函数做出了改进，废弃了<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">raw_input</font>函数。</li>
<li>Python 2 中的<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">file</font>函数被 Python 3 中的<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">open</font>函数取代。</li>
<li>Python 2 中的<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">&#x2F;</font>运算对于<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">int</font>类型是整除，在 Python 3 中要用*<font style="color:rgb(92, 99, 112);background-color:rgb(40, 44, 52);">&#x2F;&#x2F;</font>*来做整除除法。</li>
<li>Python 3 中改进了 Python 2 捕获异常的代码，很明显 Python 3 的写法更合理。</li>
<li>Python 3 生成式中循环变量的作用域得到了更好的控制，不会影响到生成式之外的同名变量。</li>
<li>Python 3 中的<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">round</font>函数可以返回<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">int</font>或<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">float</font>类型，Python 2 中的<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">round</font>函数返回<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">float</font>类型。</li>
<li>Python 3 的<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">str</font>类型是 Unicode 字符串，Python 2 的<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">str</font>类型是字节串，相当于 Python 3 中的<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">bytes</font>。</li>
<li>Python 3 中的比较运算符必须比较同类对象。</li>
<li>Python 3 中定义类的都是新式类，Python 2 中定义的类有新式类（显式继承自<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">object</font>的类）和旧式类（经典类）之分，新式类和旧式类在 MRO 问题上有非常显著的区别，新式类可以使用<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>class</strong><code>属性获取自身类型，新式类可以使用</code><strong>slots</strong></font>魔法。</li>
<li>Python 3 对代码缩进的要求更加严格，如果混用空格和制表键会引发<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">TabError</font>。</li>
<li>Python 3 中字典的<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">keys</font>、<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">values</font>、<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">items</font>方法都不再返回<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">list</font>对象，而是返回<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">view</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">object</font>，内置的<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">map</font>、<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">filter</font>等函数也不再返回<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">list</font>对象，而是返回迭代器对象。</li>
<li>Python 3 标准库中某些模块的名字跟 Python 2 是有区别的；而在三方库方面，有些三方库只支持 Python 2，有些只能支持 Python 3。</li>
</ol>
<h5 id="题目-31：谈谈你对“猴子补丁”（monkey-patching）的理解。"><a href="#题目-31：谈谈你对“猴子补丁”（monkey-patching）的理解。" class="headerlink" title="题目 31：谈谈你对“猴子补丁”（monkey patching）的理解。"></a><font style="color:rgb(85, 87, 112);">题目 31：谈谈你对“猴子补丁”（monkey patching）的理解。</font></h5><p>“猴子补丁”是动态类型语言的一个特性，代码运行时在不修改源代码的前提下改变代码中的方法、属性、函数等以达到热补丁（hot patch）的效果。很多系统的安全补丁也是通过猴子补丁的方式来实现的，但实际开发中应该避免对猴子补丁的使用，以免造成代码行为不一致的问题。</p>
<p>在使用<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">gevent</font>库的时候，我们会在代码开头的地方执行<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">gevent</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">.monkey</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">.patch_all</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">()</font>，这行代码的作用是把标准库中的<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">socket</font>模块给替换掉，这样我们在使用<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">socket</font>的时候，不用修改任何代码就可以实现对代码的协程化，达到提升性能的目的，这就是对猴子补丁的应用。</p>
<p>另外，如果希望用<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">ujson</font>三方库替换掉标准库中的<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">json</font>，也可以使用猴子补丁的方式，代码如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import json, ujson</span><br><span class="line"></span><br><span class="line">json.__name__ = &#x27;ujson&#x27;</span><br><span class="line">json.dumps = ujson.dumps</span><br><span class="line">json.loads = ujson.loads</span><br></pre></td></tr></table></figure>

<p>单元测试中的<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">Mock</font>技术也是对猴子补丁的应用，Python 中的<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">unittest</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.mock</font>模块就是解决单元测试中用<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">Mock</font>对象替代被测对象所依赖的对象的模块。</p>
<h5 id="题目-32：阅读下面的代码说出运行结果。"><a href="#题目-32：阅读下面的代码说出运行结果。" class="headerlink" title="题目 32：阅读下面的代码说出运行结果。"></a><font style="color:rgb(85, 87, 112);">题目 32：阅读下面的代码说出运行结果。</font></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">who</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;A&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">who</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(B, <span class="variable language_">self</span>).who()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;B&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">who</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(C, <span class="variable language_">self</span>).who()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;C&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">who</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(D, <span class="variable language_">self</span>).who()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;D&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">item = D()</span><br><span class="line">item.who()</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：这道题考查到了两个知识点：</font></p>
<ol>
<li><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">Python 中的 MRO（方法解析顺序）。在没有多重继承的情况下，向对象发出一个消息，如果对象没有对应的方法，那么向上（父类）搜索的顺序是非常清晰的。如果向上追溯到</font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">object</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">类（所有类的父类）都没有找到对应的方法，那么将会引发</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">AttributeError</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">异常。但是有多重继承尤其是出现菱形继承（钻石继承）的时候，向上追溯到底应该找到那个方法就得确定 MRO。Python 3 中的类以及 Python 2 中的新式类使用 C3 算法来确定 MRO，它是一种类似于广度优先搜索的方法；Python 2 中的旧式类（经典类）使用深度优先搜索来确定 MRO。在搞不清楚 MRO 的情况下，可以使用类的</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">mro</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">方法或</font><strong><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>mro</strong></font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">属性来获得类的 MRO 列表。</font></li>
<li><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">super</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">()</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">函数的使用。在使用</font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">super</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">函数时，可以通过</font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">super</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">(类型, 对象)</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">来指定对哪个对象以哪个类为起点向上搜索父类方法。所以上面</font><font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">B</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">类代码中的</font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">super</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">(B, self)</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">.who</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">()</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">表示以 B 类为起点，向上搜索</font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">self</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">（D 类对象）的</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">who</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">方法，所以会找到</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">C</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">类中的</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">who</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">方法，因为</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">D</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">类对象的 MRO 列表是</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">D –</font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">&gt;</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">B –</font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">&gt;</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">C –</font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">&gt;</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">A –</font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">&gt;</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">object</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">。</font></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACBD</span><br></pre></td></tr></table></figure>

<h5 id="题目-33：编写一个函数实现对逆波兰表达式求值，不能使用-Python-的内置函数。"><a href="#题目-33：编写一个函数实现对逆波兰表达式求值，不能使用-Python-的内置函数。" class="headerlink" title="题目 33：编写一个函数实现对逆波兰表达式求值，不能使用 Python 的内置函数。"></a><font style="color:rgb(85, 87, 112);">题目 33：编写一个函数实现对逆波兰表达式求值，不能使用 Python 的内置函数。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：逆波兰表达式也称为“后缀表达式”，相较于平常我们使用的“中缀表达式”，逆波兰表达式不需要括号来确定运算的优先级，例如</font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">5</font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">_ (</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">2</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">+</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">3</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">)</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">对应的逆波兰表达式是</font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">5</font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">2</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">3</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">+ _</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">。逆波兰表达式求值需要借助栈结构，扫描表达式遇到运算数就入栈，遇到运算符就出栈两个元素做运算，将运算结果入栈。表达式扫描结束后，栈中只有一个数，这个数就是最终的运算结果，直接出栈即可。</font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;栈（FILO）&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.elems = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, elem</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;入栈&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.elems.append(elem)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;出栈&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.elems.pop()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查栈是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.elems) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eval_suffix</span>(<span class="params">expr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;逆波兰表达式求值&quot;&quot;&quot;</span></span><br><span class="line">    operators = &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span>: operator.add,</span><br><span class="line">        <span class="string">&#x27;-&#x27;</span>: operator.sub,</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span>: operator.mul,</span><br><span class="line">        <span class="string">&#x27;/&#x27;</span>: operator.truediv</span><br><span class="line">    &#125;</span><br><span class="line">    stack = Stack()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> expr.split():</span><br><span class="line">        <span class="keyword">if</span> item.isdigit():</span><br><span class="line">            stack.push(<span class="built_in">float</span>(item))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num2 = stack.pop()</span><br><span class="line">            num1 = stack.pop()</span><br><span class="line">            stack.push(operators[item](num1, num2))</span><br><span class="line">    <span class="keyword">return</span> stack.pop()</span><br></pre></td></tr></table></figure>

<h5 id="题目-34：Python-中如何实现字符串替换操作？"><a href="#题目-34：Python-中如何实现字符串替换操作？" class="headerlink" title="题目 34：Python 中如何实现字符串替换操作？"></a><font style="color:rgb(85, 87, 112);">题目 34：Python 中如何实现字符串替换操作？</font></h5><p>Python 中实现字符串替换大致有两类方法：字符串的<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">replace</font>方法和正则表达式的<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">sub</font>方法。</p>
<p>方法一：使用字符串的<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">replace</font>方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&#x27;hello, world!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(message.replace(<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;O&#x27;</span>).replace(<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;L&#x27;</span>).replace(<span class="string">&#x27;he&#x27;</span>, <span class="string">&#x27;HE&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>方法二：使用正则表达式的<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">sub</font>方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">message = <span class="string">&#x27;hello, world!&#x27;</span></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;[aeiou]&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(pattern.sub(<span class="string">&#x27;#&#x27;</span>, message))</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">扩展</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：还有一个相关的面试题，对保存文件名的列表排序，要求文件名按照字母表和数字大小进行排序，例如对于列表</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">filenames &#x3D; [</font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">‘a12</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.txt’,</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">‘a8</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.txt’,</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">‘b10</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.txt’,</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">‘b2</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.txt’,</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">‘b19</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.txt’,</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">‘a3</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.txt’]</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，排序的结果是</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">[</font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">‘a3.txt</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">‘,</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">‘a8.txt</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">‘,</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">‘a12.txt</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">‘,</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">‘b2.txt</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">‘,</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">‘b10.txt</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">‘,</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">‘b19.txt</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">‘]</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">。提示一下，可以通过字符串替换的方式为文件名补位，根据补位后的文件名用</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">sorted</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">函数来排序，大家可以思考下这个问题如何解决。</font></p>
<h5 id="题目-35：如何剖析-Python-代码的执行性能？"><a href="#题目-35：如何剖析-Python-代码的执行性能？" class="headerlink" title="题目 35：如何剖析 Python 代码的执行性能？"></a><font style="color:rgb(85, 87, 112);">题目 35：如何剖析 Python 代码的执行性能？</font></h5><p>剖析代码性能可以使用 Python 标准库中的<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">cProfile</font>和<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">pstats</font>模块，<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">cProfile</font>的<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">run</font>函数可以执行代码并收集统计信息，创建出<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">Stats</font>对象并打印简单的剖析报告。<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">Stats</font>是<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">pstats</font>模块中的类，它是一个统计对象。当然，也可以使用三方工具<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">line_profiler</font>和<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">memory_profiler</font>来剖析每一行代码耗费的时间和内存，这两个三方工具都会用非常友好的方式输出剖析结构。如果使用 PyCharm，可以利用“Run”菜单的“Profile”菜单项对代码进行性能分析，PyCharm 中可以用表格或者调用图（Call Graph）的方式来显示性能剖析的结果。</p>
<p>下面是使用<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">cProfile</font>剖析代码性能的例子。</p>
<p><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">example</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.py</font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cProfile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> factor <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(num ** <span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> num % factor == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrimeIter</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, total</span>):</span><br><span class="line">        <span class="variable language_">self</span>.counter = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.current = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">self</span>.total = total</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.counter &lt; <span class="variable language_">self</span>.total:</span><br><span class="line">            <span class="variable language_">self</span>.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> is_prime(<span class="variable language_">self</span>.current):</span><br><span class="line">                <span class="variable language_">self</span>.current += <span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>.counter += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.current</span><br><span class="line">        <span class="keyword">raise</span> StopIteration()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cProfile.run(<span class="string">&#x27;list(PrimeIter(10000))&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>如果使用<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">line_profiler</font>三方工具，可以直接剖析<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">is</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">_p</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">rime</font>函数每行代码的性能，需要给<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">is</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">_p</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">rime</font>函数添加一个<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">profiler</font>装饰器，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@profiler</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> factor <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(num ** <span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> num % factor == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>安装<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">line_profiler</font>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install line_profiler</span><br></pre></td></tr></table></figure>

<p>使用<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">line_profiler</font>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernprof -lv example.py</span><br></pre></td></tr></table></figure>

<p>运行结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Line #    Hits    Time      Per Hit  % Time  Line Contents</span><br><span class="line">==============================================================</span><br><span class="line">     1                                       @profile</span><br><span class="line">     2                                       def is_prime(num):</span><br><span class="line">     3    86624   48420.0   0.6      50.5        for factor in range(2, int(num ** 0.5) + 1):</span><br><span class="line">     4    85624   44000.0   0.5      45.9            if num % factor == 0:</span><br><span class="line">     5    6918     3080.0   0.4       3.2                return False</span><br><span class="line">     6    1000      430.0   0.4       0.4        return True</span><br></pre></td></tr></table></figure>

<h5 id="题目-36：如何使用random模块生成随机数、实现随机乱序和随机抽样？"><a href="#题目-36：如何使用random模块生成随机数、实现随机乱序和随机抽样？" class="headerlink" title="题目 36：如何使用&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;random&lt;/font&gt;模块生成随机数、实现随机乱序和随机抽样？"></a><font style="color:rgb(85, 87, 112);">题目 36：如何使用</font><code>&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;random&lt;/font&gt;</code><font style="color:rgb(85, 87, 112);">模块生成随机数、实现随机乱序和随机抽样？</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：送人头的题目，因为 Python 标准库中的常用模块应该是 Python 开发者都比较熟悉的内容，这个问题回如果答不上来，整个面试基本也就砸锅了。</font></p>
<ol>
<li><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">random</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">random</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">()</font>函数可以生成<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">[0.0, 1.0)</font>之间的随机浮点数。</li>
<li><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">random</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">.uniform</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">(</font><font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">a</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">,</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">b</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">)</font>函数可以生成<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">[a, b]</font>或<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">[b, a]</font>之间的随机浮点数。</li>
<li><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">random</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">.randint</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">(</font><font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">a</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">,</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">b</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">)</font>函数可以生成<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">[a, b]</font>或<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">[b, a]</font>之间的随机整数。</li>
<li><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">random</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.shuffle(x)</font>函数可以实现对序列<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">x</font>的原地随机乱序。</li>
<li><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">random</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.choice(seq)</font>函数可以从非空序列中取出一个随机元素。</li>
<li><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">random.choices(population,</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">weights</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">&#x3D;None, *,</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">cum_weights</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">&#x3D;None,</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">k</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">&#x3D;1)</font>函数可以从总体中随机抽取（有放回抽样）出容量为<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">k</font>的样本并返回样本的列表，可以通过参数指定个体的权重，如果没有指定权重，个体被选中的概率均等。</li>
<li><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">random</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.sample(population, k)</font>函数可以从总体中随机抽取（无放回抽样）出容量为<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">k</font>的样本并返回样本的列表。</li>
</ol>
<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">扩展</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">random</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">模块提供的函数除了生成均匀分布的随机数外，还可以生成其他分布的随机数，例如</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">random</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">gauss</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">(mu, sigma)</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">函数可以生成高斯分布（正态分布）的随机数；</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">random</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">paretovariate</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">(</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">alpha</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">)</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">函数会生成帕累托分布的随机数；</font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">random</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.gammavariate(alpha,</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">beta</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">)</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">函数会生成伽马分布的随机数。</font></p>
<h5 id="题目-37：解释一下线程池的工作原理。"><a href="#题目-37：解释一下线程池的工作原理。" class="headerlink" title="题目 37：解释一下线程池的工作原理。"></a><font style="color:rgb(85, 87, 112);background-color:#EDCE02;">题目 37：解释一下线程池的工作原理。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:#EDCE02;">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:#EDCE02;">：池化技术就是一种典型空间换时间的策略，我们使用的</font><a href="https://link.csdn.net/?target=https://gitcode.com/SequoiaDB/SequoiaDB/overview"><font style="background-color:#EDCE02;">数据库</font></a><font style="color:rgb(79, 79, 79);background-color:#EDCE02;">连接池、线程池等都是池化技术的应用，Python 标准库</font><font style="color:rgb(171, 178, 191);background-color:#EDCE02;">currrent.futures</font><font style="color:rgb(79, 79, 79);background-color:#EDCE02;">模块的</font><font style="color:rgb(152, 195, 121);background-color:#EDCE02;">ThreadPoolExecutor</font><font style="color:rgb(79, 79, 79);background-color:#EDCE02;">就是线程池的实现，如果要弄清楚它的工作原理，可以参考下面的内容。</font></p>
<p><font style="background-color:#EDCE02;">线程池是一种用于减少线程本身创建和销毁造成的开销的技术，属于典型的空间换时间操作。如果应用程序需要频繁的将任务派发到线程中执行，线程池就是必选项，因为创建和释放线程涉及到大量的系统底层操作，开销较大，如果能够在应用程序工作期间，将创建和释放线程的操作变成预创建和借还操作，将大大减少底层开销。线程池在应用程序启动后，立即创建一定数量的线程，放入空闲队列中。这些线程最开始都处于阻塞状态，不会消耗 CPU 资源，但会占用少量的内存空间。当任务到来后，从队列中取出一个空闲线程，把任务派发到这个线程中运行，并将该线程标记为已占用。当线程池中所有的线程都被占用后，可以选择自动创建一定数量的新线程，用于处理更多的任务，也可以选择让任务排队等待直到有空闲的线程可用。在任务执行完毕后，线程并不退出结束，而是继续保持在池中等待下一次的任务。当系统比较空闲时，大部分线程长时间处于闲置状态时，线程池可以自动销毁一部分线程，回收系统资源。基于这种预创建技术，线程池将线程创建和销毁本身所带来的开销分摊到了各个具体的任务上，执行次数越多，每个任务所分担到的线程本身开销则越小。</font></p>
<p><font style="background-color:#EDCE02;">一般线程池都必须具备下面几个组成部分：</font></p>
<ol>
<li><font style="background-color:#EDCE02;">线程池管理器：用于创建并管理线程池。</font></li>
<li><font style="background-color:#EDCE02;">工作线程和线程队列：线程池中实际执行的线程以及保存这些线程的容器。</font></li>
<li><font style="background-color:#EDCE02;">任务接口：将线程执行的任务抽象出来，形成任务接口，确保线程池与具体的任务无关。</font></li>
<li><font style="background-color:#EDCE02;">任务队列：线程池中保存等待被执行的任务的容器。</font></li>
</ol>
<h5 id="题目-38：举例说明什么情况下会出现KeyError、TypeError、ValueError。"><a href="#题目-38：举例说明什么情况下会出现KeyError、TypeError、ValueError。" class="headerlink" title="题目 38：举例说明什么情况下会出现&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;KeyError&lt;/font&gt;、&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;TypeError&lt;/font&gt;、&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;ValueError&lt;/font&gt;。"></a><font style="color:rgb(85, 87, 112);">题目 38：举例说明什么情况下会出现</font><code>&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;KeyError&lt;/font&gt;</code><font style="color:rgb(85, 87, 112);">、</font><code>&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;TypeError&lt;/font&gt;</code><font style="color:rgb(85, 87, 112);">、</font><code>&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;ValueError&lt;/font&gt;</code><font style="color:rgb(85, 87, 112);">。</font></h5><p>举一个简单的例子，变量<font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">a</font>是一个字典，执行<font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">int</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">(a[</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">‘x’</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">])</font>这个操作就有可能引发上述三种类型的异常。如果字典中没有键<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">x</font>，会引发<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">KeyError</font>；如果键<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">x</font>对应的值不是<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">str</font>、<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">float</font>、<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">int</font>、<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">bool</font>以及<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">bytes-</font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">like</font>类型，在调用<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">int</font>函数构造<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">int</font>类型的对象时，会引发<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">TypeError</font>；如果<font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">a</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">[x]</font>是一个字符串或者字节串，而对应的内容又无法处理成<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">int</font>时，将引发<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">ValueError</font>。</p>
<h5 id="题目-39：说出下面代码的运行结果。"><a href="#题目-39：说出下面代码的运行结果。" class="headerlink" title="题目 39：说出下面代码的运行结果。"></a><font style="color:rgb(85, 87, 112);">题目 39：说出下面代码的运行结果。</font></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extend_list</span>(<span class="params">val, items=[]</span>):</span><br><span class="line">    items.append(val)</span><br><span class="line">    <span class="keyword">return</span> items</span><br><span class="line"></span><br><span class="line">list1 = extend_list(<span class="number">10</span>)</span><br><span class="line">list2 = extend_list(<span class="number">123</span>, [])</span><br><span class="line">list3 = extend_list(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"><span class="built_in">print</span>(list2)</span><br><span class="line"><span class="built_in">print</span>(list3)</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：Python 函数在定义的时候，默认参数</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">items</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">的值就被计算出来了，即</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">[]</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">。因为默认参数</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">items</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">引用了对象</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">[]</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，每次调用该函数，如果对</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">items</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">引用的列表进行了操作，下次调用时，默认参数还是引用之前的那个列表而不是重新赋值为</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">[]</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，所以列表中会有之前添加的元素。如果通过传参的方式为</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">items</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">重新赋值，那么</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">items</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">将引用到新的列表对象，而不再引用默认的那个列表对象。这个题在面试中经常被问到，通常不建议使用容器类型的默认参数，像 PyLint 这样的代码检查工具也会对这种代码提出质疑和警告。</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[10, &#x27;a&#x27;]</span><br><span class="line">[123]</span><br><span class="line">[10, &#x27;a&#x27;]</span><br></pre></td></tr></table></figure>

<h5 id="题目-40：如何读取大文件，例如内存只有-4G，如何读取一个大小为-8G-的文件？"><a href="#题目-40：如何读取大文件，例如内存只有-4G，如何读取一个大小为-8G-的文件？" class="headerlink" title="题目 40：如何读取大文件，例如内存只有 4G，如何读取一个大小为 8G 的文件？"></a><font style="color:rgb(85, 87, 112);">题目 40：如何读取大文件，例如内存只有 4G，如何读取一个大小为 8G 的文件？</font></h5><p>很显然 4G 内存要一次性的加载大小为 8G 的文件是不现实的，遇到这种情况必须要考虑多次读取和分批次处理。在 Python 中读取文件可以先通过<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">open</font>函数获取文件对象，在读取文件时，可以通过<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">read</font>方法的<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">size</font>参数指定读取的大小，也可以通过<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">seek</font>方法的<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">offset</font>参数指定读取的位置，这样就可以控制单次读取数据的字节数和总字节数。除此之外，可以使用内置函数<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">iter</font>将文件对象处理成迭代器对象，每次只读取少量的数据进行处理，代码大致写法如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&#x27;...&#x27;, &#x27;rb&#x27;) as file:</span><br><span class="line">    for data in iter(lambda: file.read(2097152), b&#x27;&#x27;):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>

<p>在 Linux 系统上，可以通过<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">split</font>命令将大文件切割为小片，然后通过读取切割后的小文件对数据进行处理。例如下面的命令将名为<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">filename</font>的大文件切割为大小为 512M 的多个文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split -b 512m filename</span><br></pre></td></tr></table></figure>

<p>如果愿意， 也可以将名为<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">filename</font>的文件切割为 10 个文件，命令如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split -n 10 filename</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">扩展</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：外部排序跟上述的情况非常类似，由于处理的数据不能一次装入内存，只能放在读写较慢的外存储器（通常是硬盘）上。“</font><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">排序-归并算法</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">”就是一种常用的外部排序策略。在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件，然后在归并阶段将这些临时文件组合为一个大的有序文件，这个大的有序文件就是排序的结果。</font></p>
<h5 id="题目-41：说一下你对-Python-中模块和包的理解。"><a href="#题目-41：说一下你对-Python-中模块和包的理解。" class="headerlink" title="题目 41：说一下你对 Python 中模块和包的理解。"></a><font style="color:rgb(85, 87, 112);">题目 41：说一下你对 Python 中模块和包的理解。</font></h5><p>每个 Python 文件就是一个模块，而保存这些文件的文件夹就是一个包，但是这个作为 Python 包的文件夹必须要有一个名为*<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>init</strong></font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.py</font>的文件，否则无法导入这个包。通常一个文件夹下还可以有子文件夹，这也就意味着一个包下还可以有子包，子包中的</em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>init</strong></font>*<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">.py</font>并不是必须的。模块和包解决了 Python 中命名冲突的问题，不同的包下可以有同名的模块，不同的模块下可以有同名的变量、函数或类。在 Python 中可以使用<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">import</font>或<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">from</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">…</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">import</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">…</font>来导入包和模块，在导入的时候还可以使用<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">as</font>关键字对包、模块、类、函数、变量等进行别名，从而彻底解决编程中尤其是多人协作团队开发时的命名冲突问题。</p>
<h5 id="题目-42：说一下你知道的-Python-编码规范。"><a href="#题目-42：说一下你知道的-Python-编码规范。" class="headerlink" title="题目 42：说一下你知道的 Python 编码规范。"></a><font style="color:rgb(85, 87, 112);">题目 42：说一下你知道的 Python 编码规范。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：企业的 Python 编码规范基本上是参照 PEP-8 或谷歌开源项目风格指南来制定的，后者还提到了可以使用 Lint 工具来检查代码的规范程度，面试的时候遇到这类问题，可以先说下这两个参照标准，然后挑重点说一下 Python 编码的注意事项。</font></p>
<ol>
<li><font style="color:rgb(85, 87, 112);">空格的使用</font></li>
</ol>
<ul>
<li>使用空格来表示缩进而不要用制表符（Tab）。</li>
<li>和语法相关的每一层缩进都用 4 个空格来表示。</li>
<li>每行的字符数不要超过 79 个字符，如果表达式因太长而占据了多行，除了首行之外的其余各行都应该在正常的缩进宽度上再加上 4 个空格。</li>
<li>函数和类的定义，代码前后都要用两个空行进行分隔。</li>
<li>在同一个类中，各个方法之间应该用一个空行进行分隔。</li>
<li>二元运算符的左右两侧应该保留一个空格，而且只要一个空格就好。</li>
</ul>
<ol>
<li><font style="color:rgb(85, 87, 112);">标识符命名</font></li>
</ol>
<ul>
<li>变量、函数和属性应该使用小写字母来拼写，如果有多个单词就使用下划线进行连接。</li>
<li>类中受保护的实例属性，应该以一个下划线开头。</li>
<li>类中私有的实例属性，应该以两个下划线开头。</li>
<li>类和异常的命名，应该每个单词首字母大写。</li>
<li>模块级别的常量，应该采用全大写字母，如果有多个单词就用下划线进行连接。</li>
<li>类的实例方法，应该把第一个参数命名为<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">self</font>以表示对象自身。</li>
<li>类的类方法，应该把第一个参数命名为<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">cls</font>以表示该类自身。</li>
</ul>
<ol>
<li><font style="color:rgb(85, 87, 112);">表达式和语句</font></li>
</ol>
<ul>
<li>采用内联形式的否定词，而不要把否定词放在整个表达式的前面。例如：<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">if</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">a</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">is not</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">b</font>就比<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">if not</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">a</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">is</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">b</font>更容易让人理解。</li>
<li>不要用检查长度的方式来判断字符串、列表等是否为<font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">None</font>或者没有元素，应该用<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">if not x</font>这样的写法来检查它。</li>
<li>就算<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">if</font>分支、<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">for</font>循环、<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">except</font>异常捕获等中只有一行代码，也不要将代码和<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">if</font>、<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">for</font>、<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">except</font>等写在一起，分开写才会让代码更清晰。</li>
<li><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">import</font>语句总是放在文件开头的地方。</li>
<li>引入模块的时候，<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">from</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">math</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">import</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">sqrt</font>比<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">import</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">math</font>更好。</li>
<li>如果有多个<font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">import</font>语句，应该将其分为三部分，从上到下分别是 Python<strong>标准模块</strong>、<strong>第三方模块</strong>和<strong>自定义模块</strong>，每个部分内部应该按照模块名称的<strong>字母表顺序</strong>来排列。</li>
</ul>
<h5 id="题目-43：运行下面的代码是否会报错，如果报错请说明哪里有什么样的错，如果不报错请说出代码的执行结果。"><a href="#题目-43：运行下面的代码是否会报错，如果报错请说明哪里有什么样的错，如果不报错请说出代码的执行结果。" class="headerlink" title="题目 43：运行下面的代码是否会报错，如果报错请说明哪里有什么样的错，如果不报错请说出代码的执行结果。"></a><font style="color:rgb(85, 87, 112);">题目 43：运行下面的代码是否会报错，如果报错请说明哪里有什么样的错，如果不报错请说出代码的执行结果。</font></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__value = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">value</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__value</span><br><span class="line"></span><br><span class="line">obj = A(<span class="number">1</span>)</span><br><span class="line">obj.__value = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(obj.value)</span><br><span class="line"><span class="built_in">print</span>(obj.__value)</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：这道题有两个考察点，一个考察点是对</font><font style="color:rgb(86, 182, 194);background-color:rgb(40, 44, 52);">_</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">和</font><font style="color:rgb(97, 174, 238);background-color:rgb(40, 44, 52);">__</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">开头的对象属性访问权限以及</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">@</font><font style="color:rgb(198, 120, 221);background-color:rgb(40, 44, 52);">property</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">装饰器的了解，另外一个考察的点是对动态语言的理解，不需要过多的解释。</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">扩展</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：如果不希望代码运行时动态的给对象添加新属性，可以在定义类时使用</font><em><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"><strong>slots</strong></font></em><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">魔法。例如，我们可以在上面的</font><font style="color:rgb(224, 108, 117);background-color:rgb(40, 44, 52);">A</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">中添加一行</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);"><strong>slots</strong></font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">&#x3D; (</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">‘__value’</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">, )</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，再次运行上面的代码，将会在原来的第 10 行处产生</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">AttributeError</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">错误。</font></p>
<h5 id="题目-44：对下面给出的字典按值从大到小对键进行排序。"><a href="#题目-44：对下面给出的字典按值从大到小对键进行排序。" class="headerlink" title="题目 44：对下面给出的字典按值从大到小对键进行排序。"></a><font style="color:rgb(85, 87, 112);">题目 44：对下面给出的字典按值从大到小对键进行排序。</font></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">prices = &#123;</span><br><span class="line">    &#x27;AAPL&#x27;: 191.88,</span><br><span class="line">    &#x27;GOOG&#x27;: 1186.96,</span><br><span class="line">    &#x27;IBM&#x27;: 149.24,</span><br><span class="line">    &#x27;ORCL&#x27;: 48.44,</span><br><span class="line">    &#x27;ACN&#x27;: 166.89,</span><br><span class="line">    &#x27;FB&#x27;: 208.09,</span><br><span class="line">    &#x27;SYMC&#x27;: 21.29</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">sorted</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">函数的高阶用法在面试的时候经常出现，</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">key</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">参数可以传入一个函数名或一个 Lambda 函数，该函数的返回值代表了在排序时比较元素的依据。</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sorted(prices, key=lambda x: prices[x], reverse=True)</span><br></pre></td></tr></table></figure>

<h5 id="题目-45：说一下namedtuple的用法和作用。"><a href="#题目-45：说一下namedtuple的用法和作用。" class="headerlink" title="题目 45：说一下&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;namedtuple&lt;/font&gt;的用法和作用。"></a><font style="color:rgb(85, 87, 112);">题目 45：说一下</font><code>&lt;font style=&quot;color:rgb(85, 87, 112);&quot;&gt;namedtuple&lt;/font&gt;</code><font style="color:rgb(85, 87, 112);">的用法和作用。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：Python 标准库的</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">collections</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">模块提供了很多有用的数据结构，这些内容并不是每个开发者都清楚，就比如题目问到的</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">namedtuple</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，在我参加过的面试中，90%的面试者都不能准确的说出它的作用和应用场景。此外，</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">deque</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">也是一个非常有用但又经常被忽视的类，还有</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">Counter</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">、</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">OrderedDict</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);"> </font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">、</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">defaultdict</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);"> </font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">、</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">UserDict</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">等类，大家清楚它们的用法吗？</font></p>
<p>在使用面向对象编程语言的时候，定义类是最常见的一件事情，有的时候，我们会用到只有属性没有方法的类，这种类的对象通常只用于组织数据，并不能接收消息，所以我们把这种类称为数据类或者退化的类，就像 C 语言中的结构体那样。我们并不建议使用这种退化的类，在 Python 中可以用<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">namedtuple</font>（命名元组）来替代这种类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Card = namedtuple(<span class="string">&#x27;Card&#x27;</span>, (<span class="string">&#x27;suite&#x27;</span>, <span class="string">&#x27;face&#x27;</span>))</span><br><span class="line">card1 = Card(<span class="string">&#x27;红桃&#x27;</span>, <span class="number">13</span>)</span><br><span class="line">card2 = Card(<span class="string">&#x27;草花&#x27;</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;card1.suite&#125;</span><span class="subst">&#123;card1.face&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;card2.suite&#125;</span><span class="subst">&#123;card2.face&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>命名元组与普通元组一样是不可变容器，一旦将数据存储在<font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">namedtuple</font>的顶层属性中，数据就不能再修改了，也就意味着对象上的所有属性都遵循“一次写入，多次读取”的原则。和普通元组不同的是，命名元组中的数据有访问名称，可以通过名称而不是索引来获取保存的数据，不仅在操作上更加简单，代码的可读性也会更好。</p>
<p>命名元组的本质就是一个类，所以它还可以作为父类创建子类。除此之外，命名元组内置了一系列的方法，例如，可以通过<font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);"><em>asdict</font>方法将命名元组处理成字典，也可以通过<font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"></em></font><font style="color:rgb(230, 192, 123);background-color:rgb(40, 44, 52);">replace</font>方法创建命名元组对象的浅拷贝。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCard</span>(<span class="title class_ inherited__">Card</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">        faces = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;K&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.suite&#125;</span><span class="subst">&#123;faces[self.face]&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Card)    <span class="comment"># &lt;class &#x27;__main__.Card&#x27;&gt;</span></span><br><span class="line">card3 = MyCard(<span class="string">&#x27;方块&#x27;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span>(card3.show())    <span class="comment"># 方块Q</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>(card1._asdict()))    <span class="comment"># &#123;&#x27;suite&#x27;: &#x27;红桃&#x27;, &#x27;face&#x27;: 13&#125;</span></span><br><span class="line"><span class="built_in">print</span>(card2._replace(suite=<span class="string">&#x27;方块&#x27;</span>))    <span class="comment"># Card(suite=&#x27;方块&#x27;, face=5)</span></span><br></pre></td></tr></table></figure>

<p>总而言之，命名元组能更好的组织数据结构，让代码更加清晰和可读，在很多场景下是元组、字典和数据类的替代品。在需要创建占用空间更少的不可变类时，命名元组就是很好的选择。</p>
<h5 id="题目-46：按照题目要求写出对应的函数。"><a href="#题目-46：按照题目要求写出对应的函数。" class="headerlink" title="题目 46：按照题目要求写出对应的函数。"></a><font style="color:rgb(85, 87, 112);">题目 46：按照题目要求写出对应的函数。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">要求</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：写一个函数，传入一个有若干个整数的列表，该列表中某个元素出现的次数超过了 50%，返回这个元素。</font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">more_than_half</span>(<span class="params">items</span>):</span><br><span class="line">    temp, times = <span class="literal">None</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> times == <span class="number">0</span>:</span><br><span class="line">            temp = item</span><br><span class="line">            times += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> item == temp:</span><br><span class="line">                times += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                times -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> temp</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：LeetCode 上的题目，在 Python 面试中出现过，利用元素出现次数超过了 50%这一特征，出现和</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">temp</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">相同的元素就将计数值加 1，出现和</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">temp</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">不同的元素就将计数值减 1。如果计数值为</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">0</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，说明之前出现的元素已经对最终的结果没有影响，用</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">temp</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">记下当前元素并将计数值置为</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">1</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">。最终，出现次数超过了 50%的这个元素一定会被赋值给变量</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">temp</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">。</font></p>
<h5 id="题目-47：按照题目要求写出对应的函数。"><a href="#题目-47：按照题目要求写出对应的函数。" class="headerlink" title="题目 47：按照题目要求写出对应的函数。"></a><font style="color:rgb(85, 87, 112);">题目 47：按照题目要求写出对应的函数。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">要求</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：写一个函数，传入的参数是一个列表（列表中的元素可能也是一个列表），返回该列表最大的嵌套深度。例如：列表</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">[1, 2, 3]</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">的嵌套深度为</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">1</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，列表</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">[[1], [2, [3]]</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">]</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">的嵌套深度为</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">3</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">。</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def list_depth(items):</span><br><span class="line">    if isinstance(items, list):</span><br><span class="line">        max_depth = 1</span><br><span class="line">        for item in items:</span><br><span class="line">            max_depth = max(list_depth(item) + 1, max_depth)</span><br><span class="line">        return max_depth</span><br><span class="line">    return 0</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：看到题目应该能够比较自然的想到使用递归的方式检查列表中的每个元素。</font></p>
<h5 id="题目-48：按照题目要求写出对应的装饰器。"><a href="#题目-48：按照题目要求写出对应的装饰器。" class="headerlink" title="题目 48：按照题目要求写出对应的装饰器。"></a><font style="color:rgb(85, 87, 112);">题目 48：按照题目要求写出对应的装饰器。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">要求</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：有一个通过网络获取数据的函数（可能会因为网络原因出现异常），写一个装饰器让这个函数在出现指定异常时可以重试指定的次数，并在每次重试之前随机延迟一段时间，最长延迟时间可以通过参数进行控制。</font></p>
<p>方法一：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">retry</span>(<span class="params">*, retry_times=<span class="number">3</span>, max_wait_secs=<span class="number">5</span>, errors=(<span class="params">Exception, </span>)</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorate</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(retry_times):</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">                <span class="keyword">except</span> errors:</span><br><span class="line">                    sleep(random() * max_wait_secs)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorate</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from functools import wraps</span><br><span class="line">from random import random</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Retry(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, *, retry_times=3, max_wait_secs=5, errors=(Exception, )):</span><br><span class="line">        self.retry_times = retry_times</span><br><span class="line">        self.max_wait_secs = max_wait_secs</span><br><span class="line">        self.errors = errors</span><br><span class="line"></span><br><span class="line">    def __call__(self, func):</span><br><span class="line"></span><br><span class="line">        @wraps(func)</span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            for _ in range(self.retry_times):</span><br><span class="line">                try:</span><br><span class="line">                    return func(*args, **kwargs)</span><br><span class="line">                except self.errors:</span><br><span class="line">                    sleep(random() * self.max_wait_secs)</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">        return wrapper</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：我们不止一次强调过，装饰器几乎是 Python 面试必问内容，这个题目比之前的题目稍微复杂一些，它需要的是一个参数化的装饰器。</font></p>
<h5 id="题目-49：写一个函数实现字符串反转，尽可能写出你知道的所有方法。"><a href="#题目-49：写一个函数实现字符串反转，尽可能写出你知道的所有方法。" class="headerlink" title="题目 49：写一个函数实现字符串反转，尽可能写出你知道的所有方法。"></a><font style="color:rgb(85, 87, 112);">题目 49：写一个函数实现字符串反转，尽可能写出你知道的所有方法。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：烂大街的题目，基本上算是送人头的题目。</font></p>
<p><strong>方法一</strong>：反向切片</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def reverse_string(content):</span><br><span class="line">    return content[::-1]</span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong>：反转拼接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def reverse_string(content):</span><br><span class="line">    return &#x27;&#x27;.join(reversed(content))</span><br></pre></td></tr></table></figure>

<p><strong>方法三</strong>：递归调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def reverse_string(content):</span><br><span class="line">    if len(content) &lt;= 1:</span><br><span class="line">        return content</span><br><span class="line">    return reverse_string(content[1:]) + content[0]</span><br></pre></td></tr></table></figure>

<p><strong>方法四</strong>：双端队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line"></span><br><span class="line">def reverse_string(content):</span><br><span class="line">    q = deque()</span><br><span class="line">    q.extendleft(content)</span><br><span class="line">    return &#x27;&#x27;.join(q)</span><br></pre></td></tr></table></figure>

<p><strong>方法五</strong>：反向组装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from io import StringIO</span><br><span class="line"></span><br><span class="line">def reverse_string(content):</span><br><span class="line">    buffer = StringIO()</span><br><span class="line">    for i in range(len(content) - 1, -1, -1):</span><br><span class="line">        buffer.write(content[i])</span><br><span class="line">    return buffer.getvalue()</span><br></pre></td></tr></table></figure>

<p><strong>方法六</strong>：反转拼接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def reverse_string(content):</span><br><span class="line">    return &#x27;&#x27;.join([content[i] for i in range(len(content) - 1, -1, -1)])</span><br></pre></td></tr></table></figure>

<p><strong>方法七</strong>：半截交换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def reverse_string(content):</span><br><span class="line">    length, content= len(content), list(content)</span><br><span class="line">    for i in range(length // 2):</span><br><span class="line">        content[i], content[length - 1 - i] = content[length - 1 - i], content[i]</span><br><span class="line">    return &#x27;&#x27;.join(content)</span><br></pre></td></tr></table></figure>

<p><strong>方法八</strong>：对位交换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def reverse_string(content):</span><br><span class="line">    length, content= len(content), list(content)</span><br><span class="line">    for i, j in zip(range(length // 2), range(length - 1, length // 2 - 1, -1)):</span><br><span class="line">        content[i], content[j] = content[j], content[i]</span><br><span class="line">    return &#x27;&#x27;.join(content)</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">扩展</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：这些方法其实都是大同小异的，面试的时候能够给出几种有代表性的就足够了。给大家留一个思考题，上面这些方法，哪些做法的性能较好呢？我们之前提到过剖析代码性能的方法，大家可以用这些方法来检验下你给出的答案是否正确。</font></p>
<h5 id="题目-50：按照题目要求写出对应的函数。"><a href="#题目-50：按照题目要求写出对应的函数。" class="headerlink" title="题目 50：按照题目要求写出对应的函数。"></a><font style="color:rgb(85, 87, 112);">题目 50：按照题目要求写出对应的函数。</font></h5><p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">要求</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：列表中有</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">1000000</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">个元素，取值范围是</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">[</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">1000</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">,</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);"> </font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">10000</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">)</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，设计一个函数找出列表中的重复元素。</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def find_dup(items: list):</span><br><span class="line">    dups = [0] * 9000</span><br><span class="line">    for item in items:</span><br><span class="line">        dups[item - 1000] += 1</span><br><span class="line">    for idx, val in enumerate(dups):</span><br><span class="line">        if val &gt; 1:</span><br><span class="line">            yield idx + 1000</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">点评</font></strong><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">：这道题的解法和计数排序的原理一致，虽然元素的数量非常多，但是取值范围</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">[</font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">1000</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">, </font><font style="color:rgb(209, 154, 102);background-color:rgb(40, 44, 52);">10000</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">)</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">并不是很大，只有 9000 个可能的取值，所以可以用一个能够保存 9000 个元素的</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">dups</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">列表来记录每个元素出现的次数，</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">dups</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">列表所有元素的初始值都是</font><font style="color:rgb(171, 178, 191);background-color:rgb(40, 44, 52);">0</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">，通过对</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">items</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">列表中元素的遍历，当出现某个元素时，将</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">dups</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">列表对应位置的值加 1，最后</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">dups</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">列表中值大于 1 的元素对应的就是</font><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);">items</font><font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">列表中重复出现过的元素。</font></p>
<blockquote>
<p>更新: 2024-05-02 11:38:36<br>原文: <a target="_blank" rel="noopener" href="https://www.yuque.com/zacharyblock/cx2om6/slgtyqlpzyibq4yr">https://www.yuque.com/zacharyblock/cx2om6/slgtyqlpzyibq4yr</a></p>
</blockquote>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Zachary Block</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://blockzachary.github.io/2024/03/19/%E9%9D%A2%E7%BB%8F_%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E7%BB%8F2/">https://blockzachary.github.io/2024/03/19/%E9%9D%A2%E7%BB%8F_%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E7%BB%8F2/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Python/"># Python</a>
                    
                        <a href="/tags/%E9%9D%A2%E7%BB%8F/"># 面经</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2024/05/03/FastAPI%E5%85%A5%E9%97%A8/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/">项目介绍</a>
            
            
            <a class="next" rel="next" href="/2024/03/18/%E9%9D%A2%E7%BB%8F_%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E7%BB%8F/">面经</a>
            
        </section>


    </article>
</div>

<script src="/js/clipboard.min.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', function () {
        var codeBlocks = document.querySelectorAll('article .code pre');

        codeBlocks.forEach(function (codeBlock) {
            var copyButton = document.createElement('button');
            copyButton.className = 'copy-button';
            copyButton.innerText = 'Copy';

            // Check if the code block is in the article content
            if (codeBlock.closest('article')) {
                codeBlock.parentNode.style.position = 'relative';
                codeBlock.parentNode.appendChild(copyButton); // 将按钮添加到 codeBlock 的父节点内

                var isCopying = false;

                copyButton.addEventListener('click', function () {
                    if (!isCopying) {
                        var codeText = codeBlock.innerText;
                        navigator.clipboard.writeText(codeText).then(function () {
                            copyButton.innerText = 'Copied!';
                            isCopying = true;
                            setTimeout(function () {
                                copyButton.innerText = 'Copy';
                                isCopying = false;
                            }, 1500);
                        }).catch(function (err) {
                            console.error('Copy failed', err);
                        });
                    }
                });
            }
        });
    });
</script>

<style>
    .copy-button {
        position: absolute;
        top: 0;
        right: 0;
        background-color: #2d96bd;
        color: #fff;
        border: none;
        border-radius: 10%;
        padding: 5px 10px;
        cursor: pointer;
    }
</style>
            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Zachary Block | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>